#define concat #1#2
#if 0

#endif
#define FLAGS_NONE // This instruction does not affect flags.
#define FLAGS_N_AND_Z // This instruction can affect the N and Z flags.
#define FLAGS_ONLY(f) // This instruction can only affect the f flag.
#define FLAGS_ALL // This instruction can affect N, V, Z, and C flags.
#if 0


#endif
#define DESCRIBE_OP o:  opcode
#define DESCRIBE_REG(small, large) small: concat(r,large)
#define DESCRIBE_RA DESCRIBE_REG(a,A)
#define DESCRIBE_RB DESCRIBE_REG(b,B)
#define DESCRIBE_RC DESCRIBE_REG(c,C)
#define DESCRIBE_RD DESCRIBE_REG(d,D)
#define DESCRIBE_RX DESCRIBE_REG(x,X)
#define DESCRIBE_IMM(x) i:  x-bit immediate value
#define DESCRIBE_IMM_UNSIGNED(x) DESCRIBE_IMM(zero-extended x)
#define DESCRIBE_IMM_SIGNED(x) DESCRIBE_IMM(sign-extended x)
#define DESCRIBE_INSTRUCTIONS Instructions:
#define DESCRIBE_PSEUDO_INSTRUCTION // Pseudo instruction:
#if 0


#endif
#define _DESCRIBE_LOAD_PART_1(x) // Load x-bit value from address
#define _DESCRIBE_LOAD_US_PART_1(us, x) // Load us x-bit value from address
#define _DESCRIBE_LOAD_PART_2(arg_address) arg_address into ARG_REG(A).
#define DESCRIBE_LOAD_32(arg_address) _DESCRIBE_LOAD_PART_1(32) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_16_UNSIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(zero-extended,16) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_16_SIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(sign-extended,16) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_8_UNSIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(zero-extended,8) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_8_SIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(sign-extended,8) _DESCRIBE_LOAD_PART_2(arg_address)
#if 0


#endif
#define _DESCRIBE_STORE(x, arg_address) // Store x ARG_REG(A) to address arg_address.
#define DESCRIBE_STORE_32(arg_address) _DESCRIBE_STORE(32-bit value in,arg_address)
#define DESCRIBE_STORE_16(arg_address) _DESCRIBE_STORE(low 16 bits of,arg_address)
#define DESCRIBE_STORE_8(arg_address) _DESCRIBE_STORE(low 8 bits of,arg_address)
#if 0


#endif
#define _DESCRIBE_ROTATE(lr, amount, src, dst) // Rotate src lr by amount, then store result in dst
#define DESCRIBE_ROTATE_NOT_THROUGH_CARRY(lr, amount) _DESCRIBE_ROTATE(lr (NOT through carry),amount bits,ARG_REG(A),ARG_REG(A)).
#define DESCRIBE_ROTATE_THROUGH_CARRY(lr) _DESCRIBE_ROTATE(lr (THROUGH carry),1 bit,ARG_REG(B),ARG_REG(A)).
#define DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(lr, amount, rotate_arg) _DESCRIBE_ROTATE(lr,amount bits,rotate_arg,ARG_REG(A)).
#if 0


#endif
#define DESCRIBE_ZERO_EXTEND // This zero-extends the value.
#define DESCRIBE_SIGN_EXTEND // This sign-extends the value.
#if 0


#endif
#define DESCRIBE_JUMP_DESTINATION_ADDRESS(addr) // Set pc to destination address in addr.
#define DESCRIBE_CALL_DESTINATION_ADDRESS(addr) // Subroutine call using addr as destination address. 
#define DESCRIBE_CALL_RETURN_ADDRESS // The return address is stored in the link register (lr).
#define DESCRIBE_BRANCH_TARGET to ((pc when instruction starts + 4)\
		// + (sign-extended 16-bit immediate value))
#if 0


#endif
#define GROUP_HEADER(x) Group x Instructions
#if 0


#endif
#define ARG_REG(x) concat(r,x)
#define ARG_IRA ira
#define ARG_SP sp
#define ARG_PC pc
#define ARG_FLAGS flags
#define ARG_TEMP temp
#define ARG_IMM imm
#define IMM_ZERO_EXTENDED (zero-extended ARG_IMM)
#define IMM_SIGN_EXTENDED (sign-extended ARG_IMM)
#define ARG_ABS absolute_addr
#define ARG_FOR_LDST_NON_INDEXED ARG_REG(B)
#define ARG_FOR_LDST_IMM_INDEXED(immediate) (ARG_FOR_LDST_NON_INDEXED + immediate)
#define ARG_FOR_LDST_TWO_REG_INDEXED (ARG_FOR_LDST_NON_INDEXED + ARG_REG(C))
#define ARG_FOR_LDST_GENERIC_INDEXED(immediate) (ARG_FOR_LDST_NON_INDEXED + ARG_REG(C) + immediate)
#define ARG_FOR_LDST_ABS ARG_ABS
#define ARG_FOR_LDST_ABS_INDEXED (ARG_FOR_LDST_ABS + ARG_REG(B))
#define ARG_CARRY carry_flag
#define IGNORE_REG(x) // Note that ARG_REG(x) is ignored.
#if 0


#endif
#define INSTR_NO_ARGS(instr) instr
#define INSTR_ONE_ARG(instr, arg) INSTR_NO_ARGS(instr) arg
#define INSTR_IMM(instr, immediate) INSTR_ONE_ARG(instr,immediate)
#define INSTR_WITH_REG(instr, regno) INSTR_ONE_ARG(instr,ARG_REG(regno))
#define INSTR_RA(instr) INSTR_WITH_REG(instr,A)
#define INSTR_RA_IMM(instr, immediate) INSTR_RA(instr), immediate
#define INSTR_RA_RB(instr) INSTR_RA(instr), ARG_REG(B)
#define INSTR_RA_RB_IMM(instr, immediate) INSTR_RA_RB(instr), immediate
#define INSTR_RA_RB_RC(instr) INSTR_RA_RB(instr), ARG_REG(C)
#define INSTR_RA_RB_RC_IMM(instr, immediate) INSTR_RA_RB_RC(instr), immediate
#define INSTR_LDST_RA_RB_RC_IMM(instr, immediate) INSTR_RA(instr), [ARG_REG(B), ARG_REG(C), immediate]
#define INSTR_LDST_RA_RB_RC(instr) INSTR_RA(instr), [ARG_REG(B), ARG_REG(C)]
#define INSTR_LDST_RA_RB_IMM(instr, immediate) INSTR_RA(instr), [ARG_REG(B), immediate]
#define INSTR_LDST_RA_RB(instr) INSTR_RA(instr), [ARG_REG(B)]
#define INSTR_LDST_RA_IMM(instr, immediate) INSTR_RA(instr), [immediate]
#define INSTR_LDST_GENERIC_RA_RB_RC_IMM(instr, rB, rC, immediate) INSTR_RA(instr), [rB, rC, immediate]
#define INSTR_IRA(instr) INSTR_ONE_ARG(instr,ARG_IRA)
#define INSTR_RA_IRA(instr) INSTR_RA(instr), ARG_IRA
#define INSTR_RA_FLAGS(instr) INSTR_RA(instr), ARG_FLAGS
#define INSTR_FLAGS(instr) INSTR_ONE_ARG(instr,ARG_FLAGS)
#define INSTR_FLAGS_RA(instr) INSTR_FLAGS(instr), ARG_REG(A)
#define INSTR_RA_PC(instr) INSTR_RA(instr), ARG_PC
#define INSTR_IRA_RA(instr) INSTR_IRA(instr), ARG_REG(A)
#define PSEUDO_INSTR_RB(instr) INSTR_WITH_REG(instr,B)
#define PSEUDO_INSTR_RB_IMM(instr, immediate) PSEUDO_INSTR_RB(instr), immediate
#define PSEUDO_INSTR_RB_RC(instr) PSEUDO_INSTR_RB(instr), ARG_REG(C)
#define PSEUDO_INSTR_RB_RC_IMM(instr, immediate) PSEUDO_INSTR_RB_RC(instr), immediate
#define PSEUDO_INSTR_RA_RC(instr) INSTR_RA(instr), ARG_REG(C)
#define PSEUDO_INSTR_PC_RB(instr) INSTR_ONE_ARG(instr,ARG_PC), ARG_REG(B)
#define DESCRIBE_PSEUDO_INSTR_ENCODING(real_instr, arg) //// Encoded like this:  real_instr arg
#define DESCRIBE_PSEUDO_INSTR_ENCODING_2(real_instr, arg) // Encoded like this:  real_instr arg
#define DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(real_ldst_instr) //// Encoded like this:  real_ldst_instr
#define DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(real_instr, arg) DESCRIBE_PSEUDO_INSTR_ENCODING(real_instr,ARG_REG(0)\, arg)
#define DESCRIBE_PSEUDO_INSTR_T_ENCODING(real_instr, first_arg, last_arg) DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(real_instr,first_arg\, last_arg)
#define RESERVED // Reserved for future expansion.
#if 0


#endif
#define GEN_MOST_LDST(arg_address, suffix) DESCRIBE_LOAD_32(arg_address)\
		__TEMP_LDST_INSTR_TYPE(concat(ldr,suffix))\
\
		DESCRIBE_LOAD_16_UNSIGNED(arg_address)\
		DESCRIBE_ZERO_EXTEND\
		__TEMP_LDST_INSTR_TYPE(concat(ldh,suffix))\
\
		DESCRIBE_LOAD_16_SIGNED(arg_address)\
		DESCRIBE_SIGN_EXTEND\
		__TEMP_LDST_INSTR_TYPE(concat(ldsh,suffix))\
\
		DESCRIBE_LOAD_8_UNSIGNED(arg_address)\
		DESCRIBE_ZERO_EXTEND\
		__TEMP_LDST_INSTR_TYPE(concat(ldb,suffix))\
\
\
\
		DESCRIBE_LOAD_8_SIGNED(arg_address)\
		DESCRIBE_SIGN_EXTEND\
		__TEMP_LDST_INSTR_TYPE(concat(ldsb,suffix))\
\
		DESCRIBE_STORE_32(arg_address)\
		__TEMP_LDST_INSTR_TYPE(concat(str,suffix))\
\
		DESCRIBE_STORE_16(arg_address)\
		__TEMP_LDST_INSTR_TYPE(concat(sth,suffix))\
\
		DESCRIBE_STORE_8(arg_address)\
		__TEMP_LDST_INSTR_TYPE(concat(stb,suffix))
#define GEN_MOST_PSEUDO_LDST(arg_address, suffix, encoding_suffix, encoding_args) DESCRIBE_PSEUDO_INSTRUCTION\
		//DESCRIBE_LOAD_32(arg_address)\
		DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(__TEMP_LDST_INSTR_TYPE_2(concat(ldr,encoding_suffix),encoding_args))\
		//__TEMP_LDST_INSTR_TYPE(concat(ldr,suffix))\
\
		DESCRIBE_PSEUDO_INSTRUCTION\
		//DESCRIBE_LOAD_16_UNSIGNED(arg_address)\
		//DESCRIBE_ZERO_EXTEND\
		DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(__TEMP_LDST_INSTR_TYPE_2(concat(ldh,encoding_suffix),encoding_args))\
		//__TEMP_LDST_INSTR_TYPE(concat(ldh,suffix))\
\
		DESCRIBE_PSEUDO_INSTRUCTION\
		//DESCRIBE_LOAD_16_SIGNED(arg_address)\
		//DESCRIBE_SIGN_EXTEND\
		DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(__TEMP_LDST_INSTR_TYPE_2(concat(ldsh,encoding_suffix),encoding_args))\
		//__TEMP_LDST_INSTR_TYPE(concat(ldsh,suffix))\
\
		DESCRIBE_PSEUDO_INSTRUCTION\
		//DESCRIBE_LOAD_8_UNSIGNED(arg_address)\
		//DESCRIBE_ZERO_EXTEND\
		DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(__TEMP_LDST_INSTR_TYPE_2(concat(ldb,encoding_suffix),encoding_args))\
		//__TEMP_LDST_INSTR_TYPE(concat(ldb,suffix))\
\
\
\
		DESCRIBE_PSEUDO_INSTRUCTION\
		//DESCRIBE_LOAD_8_SIGNED(arg_address)\
		//DESCRIBE_SIGN_EXTEND\
		DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(__TEMP_LDST_INSTR_TYPE_2(concat(ldsb,encoding_suffix),encoding_args))\
		//__TEMP_LDST_INSTR_TYPE(concat(ldsb,suffix))\
\
		DESCRIBE_PSEUDO_INSTRUCTION\
		//DESCRIBE_STORE_32(arg_address)\
		DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(__TEMP_LDST_INSTR_TYPE_2(concat(str,encoding_suffix),encoding_args))\
		//__TEMP_LDST_INSTR_TYPE(concat(str,suffix))\
\
		DESCRIBE_PSEUDO_INSTRUCTION\
		//DESCRIBE_STORE_16(arg_address)\
		DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(__TEMP_LDST_INSTR_TYPE_2(concat(sth,encoding_suffix),encoding_args))\
		//__TEMP_LDST_INSTR_TYPE(concat(sth,suffix))\
\
		DESCRIBE_PSEUDO_INSTRUCTION\
		//DESCRIBE_STORE_8(arg_address)\
		DESCRIBE_PSEUDO_INSTR_LDST_ENCODING(__TEMP_LDST_INSTR_TYPE_2(concat(stb,encoding_suffix),encoding_args))\
		//__TEMP_LDST_INSTR_TYPE(concat(stb,suffix))
#define GEN_MOST_ARITH_LOG_WITH_FLAGS(rotate_arg, arg_0, arg_1, arg_2, suffix) // arg_0 = arg_1 + arg_2\
		FLAGS_ALL\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(add,suffix))\
\
		// arg_0 = arg_1 + arg_2 + ARG_CARRY\
		// Add with carry\
		FLAGS_ALL\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(adc,suffix))\
\
		// arg_0 = arg_1 - arg_2\
		FLAGS_ALL\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(sub,suffix))\
\
		// arg_0 = arg_1 + (~arg_2) + ARG_CARRY\
		// Subtract with borrow (6502 style)\
		FLAGS_ALL\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(sbc,suffix))\
\
\
\
		// arg_0 = arg_2 - arg_1\
		FLAGS_ALL\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(rsb,suffix))\
\
		// arg_0 = arg_1 * arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(mul,suffix))\
\
		// arg_0 = arg_1 & arg_2\
		FLAGS_N_AND_Z\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(and,suffix))\
\
		// arg_0 = arg_1 | arg_2\
		FLAGS_N_AND_Z\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(or,suffix))\
\
\
\
		// arg_0 = arg_1 ^ arg_2\
		FLAGS_N_AND_Z\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(xor,suffix))\
\
		// Logical shift left\
		// arg_0 = arg_1 << arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(lsl,suffix))\
\
		// Logical shift right\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(lsr,suffix))\
\
		// Arithmetic shift right\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(asr,suffix))\
\
\
\
		DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(left,arg_2,rotate_arg)\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(rol,suffix))\
\
		DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(right,arg_2,rotate_arg)\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(ror,suffix))
#define GEN_MOST_ARITH_LOG(rotate_arg, arg_0, arg_1, arg_2, suffix) // arg_0 = arg_1 + arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(add,suffix))\
\
		// arg_0 = arg_1 + arg_2 + ARG_CARRY\
		// Add with carry\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(adc,suffix))\
\
		// arg_0 = arg_1 - arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(sub,suffix))\
\
		// arg_0 = arg_1 + (~arg_2) + ARG_CARRY\
		// Subtract with borrow (6502 style)\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(sbc,suffix))\
\
\
\
		// arg_0 = arg_2 - arg_1\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(rsb,suffix))\
\
		// arg_0 = arg_1 * arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(mul,suffix))\
\
		// arg_0 = arg_1 & arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(and,suffix))\
\
		// arg_0 = arg_1 | arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(or,suffix))\
\
\
\
		// arg_0 = arg_1 ^ arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(xor,suffix))\
\
		// Logical shift left\
		// arg_0 = arg_1 << arg_2\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(lsl,suffix))\
\
		// Logical shift right\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(lsr,suffix))\
\
		// Arithmetic shift right\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(asr,suffix))\
\
\
\
		DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(left,arg_2,rotate_arg)\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(rol,suffix))\
\
		DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(right,arg_2,rotate_arg)\
		__TEMP_ARITH_LOG_INSTR_TYPE(concat(ror,suffix))
#if 0

You won't see this sentence in the final .txt file.
It's nice, I guess

#endif
Three instruction encoding sizes:  16-bit, 32-bit, and 48-bit

The instruction group is a 2-bit field, the 2 most significant bits of the
first 16-bits.

Group 0 Instructions, for example, use 00 as their group identifier.

#if 0
To specify that an instruction is permitted to affect flags, append ".f"
(without quotes) to the end of the instruction name.  
Example:  "add" becomes "add.f"
#endif

GROUP_HEADER(0)
00oo oooo aaaa bbbb

	DESCRIBE_OP
	DESCRIBE_RA (destination register usually)
	DESCRIBE_RB

	DESCRIBE_INSTRUCTIONS
#define __TEMP_LDST_INSTR_TYPE INSTR_LDST_RA_RB
		GEN_MOST_LDST(ARG_FOR_LDST_NON_INDEXED,)
#undef __TEMP_LDST_INSTR_TYPE



#define __TEMP_ARITH_LOG_INSTR_TYPE INSTR_RA_RB
		GEN_MOST_ARITH_LOG(ARG_REG(A),ARG_REG(A),ARG_REG(A),ARG_REG(B))




		GEN_MOST_ARITH_LOG_WITH_FLAGS(ARG_REG(A),ARG_REG(A),ARG_REG(A),ARG_REG(B),.f)
#undef __TEMP_ARITH_LOG_INSTR_TYPE



		DESCRIBE_ROTATE_THROUGH_CARRY(left)
		FLAGS_ONLY(C)
		INSTR_RA_RB(rlc)

		DESCRIBE_ROTATE_THROUGH_CARRY(right)
		FLAGS_ONLY(C)
		INSTR_RA_RB(rrc)

		// ENable Interrupts
		INSTR_NO_ARGS(eni)

		// DIsable Interrupts
		INSTR_NO_ARGS(dii)



		// Copy the Interrupt Return Address to ARG_REG(A)
		INSTR_RA_IRA(cpy)

		// Copy ARG_REG(A) to the Interrupt Return Address
		INSTR_IRA_RA(cpy)

		// Set the PC to interrupt RETurn address and enable Interrupts
		INSTR_NO_ARGS(reti)

		// Set the PC to the Interrupt Return Address, but DON'T enable
		// interrupts
		INSTR_IRA(jump)



		// Push flags as 8-bit value onto the stack (high 4 bits of pushed
		// value are set to zero before the push)
		INSTR_FLAGS(push)

		// Pop 8-bit value from the stack and store low 4 bits to flags
		INSTR_FLAGS(pop)

		// Clear ARG_REG(A), then CoPY FRom Flags to ARG_REG(A)
		INSTR_RA_FLAGS(cpy)

		// Copy to flags from ARG_REG(A)
		FLAGS_ALL
		INSTR_FLAGS_RA(cpy)



		DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B)))
		DESCRIBE_CALL_RETURN_ADDRESS
		INSTR_RA_RB(callx)

		DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B)))
		INSTR_RA_RB(jumpx)

		// Copy (pc when instructions starts + 2) to ARG_REG(A) (this can
		// be used for pc-relative loads and stores)
		INSTR_RA_PC(cpy)

		// Copy
		// ARG_REG(A) = ARG_REG(B)
		INSTR_RA_RB(cpy)



		// ARG_REG(A) = Sign extend of low 16 bits in ARG_REG(B)
		// Note that the high 16 bits of ARG_REG(B) are ignored
		INSTR_RA_RB(seh)

		// ARG_REG(A) = Sign extend of low 8 bits in ARG_REG(B)
		INSTR_RA_RB(seb)

		RESERVED
		RESERVED



		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED



		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_CALL_DESTINATION_ADDRESS(ARG_REG(B))
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(callx,ARG_REG(B))
		//PSEUDO_INSTR_RB(call)

		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS(ARG_REG(B))
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(jumpx,ARG_REG(B))
		//PSEUDO_INSTR_RB(jump)

		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS(ARG_REG(B))
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(jumpx,ARG_REG(B))
		//PSEUDO_INSTR_PC_RB(cpy)


GROUP_HEADER(1)
01oo oooo aaaa bbbb  iiii iiii iiii iiii

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_IMM(16)

	DESCRIBE_INSTRUCTIONS
#define __TEMP_ARITH_LOG_INSTR_TYPE INSTR_RA_RB_IMM
		GEN_MOST_ARITH_LOG(,ARG_REG(A),ARG_REG(B),IMM_ZERO_EXTENDED,i\,ARG_IMM)




		GEN_MOST_ARITH_LOG_WITH_FLAGS(,ARG_REG(A),ARG_REG(B),IMM_ZERO_EXTENDED,i.f\,ARG_IMM)
#undef __TEMP_ARITH_LOG_INSTR_TYPE




		// Branch always, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bra,ARG_IMM)

		// Branch never (effectively a NOP),
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bnv,ARG_IMM)

		// Branch when Z == 0, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bne,ARG_IMM)

		// Branch when Z == 1, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(beq,ARG_IMM)



		// Branch when C == 0 [unsigned less than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bcc,ARG_IMM)

		// Branch when C == 1 [unsigned greater than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bcs,ARG_IMM)

		// Branch when (C == 0 or Z == 1) [unsigned less than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bls,ARG_IMM)

		// Branch when (C == 1 and Z == 0) [unsigned greater than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bhi,ARG_IMM)



		// Branch when N == 0, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bpl,ARG_IMM)

		// Branch when N == 1, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bmi,ARG_IMM)

		// Branch when V == 0, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bvc,ARG_IMM)

		// Branch when V == 1, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bvs,ARG_IMM)



		// Branch when N == V [signed greater than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bge,ARG_IMM)

		// Branch when N != V [signed less than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(blt,ARG_IMM)

		// Branch when (N == V and Z == 0) [signed greater than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bgt,ARG_IMM)

		// Branch when (N != V or Z == 1) [signed less than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(ble,ARG_IMM)



		// ARG_REG(A) = ARG_REG(B) ^ IMM_SIGN_EXTENDED
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(xorsi,ARG_IMM)

		// ARG_REG(A) bits {31, 30, 29, ..., 18, 17, 16} = 16-bit unsigned immediate value
		INSTR_RA_IMM(lui,ARG_IMM)

		RESERVED
		RESERVED



		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED



		DESCRIBE_PSEUDO_INSTRUCTION
		//// Compare ARG_REG(B) to IMM_ZERO_EXTENDED
		//// ARG_TEMP = ARG_REG(B) - IMM_ZERO_EXTENDED
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(subi.f,ARG_REG(B),ARG_IMM)
		//FLAGS_ALL
		//PSEUDO_INSTR_RB_IMM(cmpi,ARG_IMM)

		DESCRIBE_PSEUDO_INSTRUCTION
		//// Compare ARG_REG(B) to negated IMM_ZERO_EXTENDED
		//// ARG_TEMP = ARG_REG(B) - (-IMM_ZERO_EXTENDED)
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(addi.f,ARG_REG(B),ARG_IMM)
		//FLAGS_ALL
		//PSEUDO_INSTR_RB_IMM(cmni,ARG_IMM)

		DESCRIBE_PSEUDO_INSTRUCTION
		//// Compare reversed with immediate value
		//// ARG_TEMP = IMM_ZERO_EXTENDED - ARG_REG(B)
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(rsbi.f,ARG_REG(B),ARG_IMM)
		//FLAGS_ALL
		//PSEUDO_INSTR_RB_IMM(cmri,ARG_IMM)

		DESCRIBE_PSEUDO_INSTRUCTION
		//// Copy Negated
		//// ARG_REG(A) = -ARG_REG(B)
		DESCRIBE_PSEUDO_INSTR_ENCODING(rsbi,ARG_REG(A)\, ARG_REG(B)\, 0)
		//INSTR_RA_RB(cpn)

		DESCRIBE_PSEUDO_INSTRUCTION
		//// Copy Complemented
		//// ARG_REG(A) = ~ARG_REG(B)
		DESCRIBE_PSEUDO_INSTR_ENCODING(xorsi,ARG_REG(A)\, ARG_REG(B)\, -1)
		//INSTR_RA_RB(cpc)




		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(B) & IMM_ZERO_EXTENDED
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(andi,ARG_REG(B),ARG_IMM)
		//FLAGS_N_AND_Z
		//PSEUDO_INSTR_RB_IMM(tsti,ARG_IMM)


GROUP_HEADER(2)
Non Block Moves Version:  
	10oo oooo aaaa bbbb  cccc iiii iiii iiii

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_IMM(12)

Block Moves Version (stmdb, ldmia, stmia, push, pop):  
	10oo oooo aaaa bbbb  cccc dddd xxxx 00ii

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_RD
	DESCRIBE_RX
	DESCRIBE_IMM(2)

	DESCRIBE_INSTRUCTIONS
#define __TEMP_LDST_INSTR_TYPE INSTR_LDST_RA_RB_RC_IMM
#if 0 GEN_MOST_LDST(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED),xx\,ARG_IMM) #endif
		GEN_MOST_LDST(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED),\,ARG_IMM)
#undef __TEMP_LDST_INSTR_TYPE


#define __TEMP_ARITH_LOG_INSTR_TYPE INSTR_RA_RB_RC
		GEN_MOST_ARITH_LOG(ARG_REG(C),ARG_REG(A),ARG_REG(B),ARG_REG(C))



		GEN_MOST_ARITH_LOG_WITH_FLAGS(ARG_REG(C),ARG_REG(A),ARG_REG(B),ARG_REG(C),.f)
#undef __TEMP_ARITH_LOG_INSTR_TYPE




		// Fused multiply-add
		// ARG_REG(A) = ARG_REG(A) + (ARG_REG(B) * ARG_REG(C))
		INSTR_RA_RB_RC(fma)

		// Copy ARG_REG(C) to ARG_REG(A) and to ARG_REG(B)
		// If ARG_REG(A) is the same register as ARG_REG(B), then the 
		// register will only be written once.
		INSTR_RA_RB_RC(cpyp)

		// STore Multiple, Decrement Before
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  10f0 oooo aaaa 0000 0000 0000 xxxx 0000
			// Effect:  
				// ARG_REG(X) -= 4;
				// [ARG_REG(X)] = ARG_REG(A);
			Syntax:  stmdb ARG_REG(X), {ARG_REG(A)}

		// Form 1:
			// Encoding:  10f0 oooo aaaa bbbb 0000 0000 xxxx 0001
			// Effect:  
				// ARG_REG(X) -= 8;
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
			Syntax:  stmdb ARG_REG(X), {ARG_REG(A), ARG_REG(B)}

		// Form 2:
			// Encoding:  10f0 oooo aaaa bbbb cccc 0000 xxxx 0010
			// Effect:  
				// ARG_REG(X) -= 12;
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
			Syntax:  stmdb ARG_REG(X), {ARG_REG(A), ARG_REG(B), ARG_REG(C)}

		// Form 3:
			// Encoding:  10f0 oooo aaaa bbbb cccc dddd xxxx 0011
			// Effect:  
				// ARG_REG(X) -= 16;
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
			Syntax:  stmdb ARG_REG(X), {ARG_REG(A), ARG_REG(B), ARG_REG(C), ARG_REG(D)}


		// LoaD Multiple, Increment After
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  10f0 oooo aaaa 0000 0000 0000 xxxx 0000
			// Effect:  
				// ARG_REG(A) = [ARG_REG(X)]; 
				// ARG_REG(X) += 4;
			Syntax:  ldmia ARG_REG(X), {ARG_REG(A)}

		// Form 1:
			// Encoding:  10f0 oooo aaaa bbbb 0000 0000 xxxx 0001
			// Effect:  
				// ARG_REG(A) = [ARG_REG(X)]; 
				// ARG_REG(B) = [ARG_REG(X) + 4];
				// ARG_REG(X) += 8;
			Syntax:  ldmia ARG_REG(X), {ARG_REG(A), ARG_REG(B)}

		// Form 2:
			// Encoding:  10f0 oooo aaaa bbbb cccc 0000 xxxx 0010
			// Effect:  
				// ARG_REG(A) = [ARG_REG(X)]; 
				// ARG_REG(B) = [ARG_REG(X) + 4];
				// ARG_REG(C) = [ARG_REG(X) + 8];
				// ARG_REG(X) += 12;
			Syntax:  ldmia ARG_REG(X), {ARG_REG(A), ARG_REG(B), ARG_REG(C)}

		// Form 3:
			// Encoding:  10f0 oooo aaaa bbbb cccc dddd xxxx 0011
			// Effect:  
				// ARG_REG(A) = [ARG_REG(X)]; 
				// ARG_REG(B) = [ARG_REG(X) + 4];
				// ARG_REG(C) = [ARG_REG(X) + 8];
				// ARG_REG(D) = [ARG_REG(X) + 12];
				// ARG_REG(X) += 16;
			Syntax:  ldmia ARG_REG(X), {ARG_REG(A), ARG_REG(B), ARG_REG(C), ARG_REG(D)}




		// STore Multiple, Increment After
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  10f0 oooo aaaa 0000 0000 0000 xxxx 0000
			// Effect:  
				// [ARG_REG(X)] = ARG_REG(A);
				// ARG_REG(X) += 4;
			Syntax:  stmia ARG_REG(X), {ARG_REG(A)}

		// Form 1:
			// Encoding:  10f0 oooo aaaa bbbb 0000 0000 xxxx 0001
			// Effect:  
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// ARG_REG(X) += 8;
			Syntax:  stmia ARG_REG(X), {ARG_REG(A), ARG_REG(B)}

		// Form 2:
			// Encoding:  10f0 oooo aaaa bbbb cccc 0000 xxxx 0010
			// Effect:  
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// ARG_REG(X) += 12;
			Syntax:  stmia ARG_REG(X), {ARG_REG(A), ARG_REG(B), ARG_REG(C)}

		// Form 3:
			// Encoding:  10f0 oooo aaaa bbbb cccc dddd xxxx 0011
			// Effect:  
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// ARG_REG(X) += 16;
			Syntax:  stmia ARG_REG(X), {ARG_REG(A), ARG_REG(B), ARG_REG(C), ARG_REG(D)}


		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED



		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

#define __TEMP_LDST_INSTR_TYPE_2 INSTR_LDST_GENERIC_RA_RB_RC_IMM
#if 0
#define __TEMP_LDST_INSTR_TYPE INSTR_LDST_RA_RB
		GEN_MOST_PSEUDO_LDST_2(ARG_FOR_LDST_NON_INDEXED,,,ARG_REG(B)\,ARG_REG(0)\,0)
#undef __TEMP_LDST_INSTR_TYPE
#endif


#define __TEMP_LDST_INSTR_TYPE INSTR_LDST_RA_RB_RC
		GEN_MOST_PSEUDO_LDST(ARG_FOR_LDST_TWO_REG_INDEXED,x,,ARG_REG(B)\,ARG_REG(C)\,0)
#undef __TEMP_LDST_INSTR_TYPE



#define __TEMP_LDST_INSTR_TYPE INSTR_LDST_RA_RB_IMM
		GEN_MOST_PSEUDO_LDST(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED),xi\,ARG_IMM,,ARG_REG(B)\,ARG_REG(0)\,ARG_IMM)
#undef __TEMP_LDST_INSTR_TYPE
#if 0
#undef __TEMP_LDST_INSTR_TYPE_2
#endif



		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(B) - ARG_REG(C)
		//FLAGS_ALL
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(sub.f,ARG_REG(B)\, ARG_REG(C))
		//PSEUDO_INSTR_RB_RC(cmp)

		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(B) - (-ARG_REG(C))
		//FLAGS_ALL
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(add.f,ARG_REG(B)\, ARG_REG(C))
		//PSEUDO_INSTR_RB_RC(cmn)

		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(C) - ARG_REG(B)
		//FLAGS_ALL
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(rsb.f,ARG_REG(B)\, ARG_REG(C))
		//PSEUDO_INSTR_RB_RC(cmr)

		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(B) & ARG_REG(C)
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(and.f,ARG_REG(B),ARG_REG(C))
		//FLAGS_N_AND_Z
		//PSEUDO_INSTR_RB_RC(tst)




		DESCRIBE_PSEUDO_INSTRUCTION
		// Pop
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  10f0 oooo aaaa 0000 0000 0000 1111 0000
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(ldmia,ARG_SP\, {ARG_REG(A)})
			// Effect:  
				// ARG_REG(A) = [ARG_SP];
				// ARG_SP += 4;
			// Syntax:  pop ARG_REG(A)

		// Form 1:
			// Encoding:  10f0 oooo aaaa bbbb 0000 0000 1111 0001
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(ldmia,ARG_SP\, {ARG_REG(A)\, ARG_REG(B)})
			// Effect:  
				// ARG_REG(A) = [ARG_SP];
				// ARG_REG(B) = [ARG_SP + 4];
				// ARG_SP += 8;
			// Syntax:  pop ARG_REG(A), ARG_REG(B)

		// Form 2:
			// Encoding:  10f0 oooo aaaa bbbb cccc 0000 1111 0010
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(ldmia,ARG_SP\, {ARG_REG(A)\, ARG_REG(B)\, ARG_REG(C)})
			// Effect:  
				// ARG_REG(A) = [ARG_SP];
				// ARG_REG(B) = [ARG_SP + 4];
				// ARG_REG(C) = [ARG_SP + 8];
				// ARG_SP += 12;
			// Syntax:  pop ARG_REG(A), ARG_REG(B), ARG_REG(C)

		// Form 3:
			// Encoding:  10f0 oooo aaaa bbbb cccc dddd 1111 0011
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(ldmia,ARG_SP\, {ARG_REG(A)\, ARG_REG(B)\, ARG_REG(C)\, ARG_REG(D)})
			// Effect:  
				// ARG_REG(A) = [ARG_SP];
				// ARG_REG(B) = [ARG_SP + 4];
				// ARG_REG(C) = [ARG_SP + 8];
				// ARG_REG(D) = [ARG_SP + 12];
				// ARG_SP += 16;
			// Syntax:  pop ARG_REG(A), ARG_REG(B), ARG_REG(C), ARG_REG(D)


		DESCRIBE_PSEUDO_INSTRUCTION
		// Push
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  10f0 oooo aaaa 0000 0000 0000 xxxx 0000
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(stmdb,ARG_SP\, {ARG_REG(A)})
			// Effect:  
				// ARG_SP -= 4;
				// [ARG_SP] = ARG_REG(A);
			// Syntax:  push ARG_REG(A)

		// Form 1:
			// Encoding:  10f0 oooo aaaa bbbb 0000 0000 xxxx 0001
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(stmdb,ARG_SP\, {ARG_REG(A)\, ARG_REG(B)})
			// Effect:  
				// ARG_SP -= 8;
				// [ARG_SP] = ARG_REG(A);
				// [ARG_SP + 4] = ARG_REG(B);
			// Syntax:  push ARG_REG(A), ARG_REG(B)

		// Form 2:
			// Encoding:  10f0 oooo aaaa bbbb cccc 0000 xxxx 0010
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(stmdb,ARG_SP\, {ARG_REG(A)\, ARG_REG(B)\, ARG_REG(C)})
			// Effect:  
				// ARG_SP -= 12;
				// [ARG_SP] = ARG_REG(A);
				// [ARG_SP + 4] = ARG_REG(B);
				// [ARG_SP + 8] = ARG_REG(C);
			// Syntax:  push ARG_REG(A), ARG_REG(B), ARG_REG(C)

		// Form 3:
			// Encoding:  10f0 oooo aaaa bbbb cccc dddd xxxx 0011
			// Effect:  
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(stmdb,ARG_SP\, {ARG_REG(A)\, ARG_REG(B)\, ARG_REG(C)\, ARG_REG(D)})
				// ARG_SP -= 16;
				// [ARG_SP] = ARG_REG(A);
				// [ARG_SP + 4] = ARG_REG(B);
				// [ARG_SP + 8] = ARG_REG(C);
				// [ARG_SP + 12] = ARG_REG(D);
			// Syntax:  push ARG_REG(A), ARG_REG(B), ARG_REG(C), ARG_REG(D)




GROUP_HEADER(3)
Two Registers Version:  
	11oo oooo aaaa bbbb  iiii iiii iiii iiii  iiii iiii iiii iiii

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_IMM(32)

Block Moves Version (stmdb, ldmia, stmia, push, pop):  
	11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh xxxx 00ii

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_RD
	DESCRIBE_REG(e,E)
	DESCRIBE_REG(f,F)
	DESCRIBE_REG(g,G)
	DESCRIBE_REG(h,H)
	DESCRIBE_RX
	DESCRIBE_IMM(2)

32-bit by 32-bit -> 64-bit Multiply Version:
	11oo oooo aaaa bbbb  cccc dddd 0000 0000  0000 0000 0000 0000

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_RD


64-bit by 64-bit -> 64-bit DivMod Version:
	11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh 0000 0000

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_RD
	DESCRIBE_REG(e,E)
	DESCRIBE_REG(f,F)
	DESCRIBE_REG(g,G)
	DESCRIBE_REG(h,H)

32-bit by 32-bit -> 32-bit DivMod Version:
	11oo oooo aaaa bbbb  cccc dddd 0000 0000  0000 0000 0000 0000

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_RD

64-bit bitshifted by 64-bit -> 64-bit Version:
	11oo oooo aaaa bbbb  cccc dddd eeee ffff  0000 0000 0000 0000

	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_RD
	DESCRIBE_REG(e,E)
	DESCRIBE_REG(f,F)


	DESCRIBE_INSTRUCTIONS
#define __TEMP_LDST_INSTR_TYPE INSTR_LDST_RA_RB_IMM
		GEN_MOST_LDST(ARG_FOR_LDST_ABS_INDEXED,a\,ARG_ABS)
#undef __TEMP_LDST_INSTR_TYPE



		DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B) + ARG_ABS))
		DESCRIBE_CALL_RETURN_ADDRESS
		INSTR_RA_RB_IMM(calla,ARG_ABS)

		DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B) + ARG_ABS))
		INSTR_RA_RB_IMM(jumpa,ARG_ABS)

		// ARG_REG(A) = 32-bit immediate, ARG_REG(B) = same 32-bit immediate
		// If ARG_REG(A) is the same register as ARG_REG(B), then the 
		// register will only be written once.
		INSTR_RA_RB_IMM(cpypi,ARG_IMM)

		// STore Multiple, Decrement Before
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee 0000  0000 0000 xxxx 0000
			// Effect:  
				// ARG_REG(X) -= 20;
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// [ARG_REG(X) + 16] = ARG_REG(E);
			Syntax:  stmdb ARG_REG(X), {rA, rB, rC, rD, rE}

		// Form 1:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  0000 0000 xxxx 0001
			// Effect:  
				// ARG_REG(X) -= 24;
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// [ARG_REG(X) + 16] = ARG_REG(E);
				// [ARG_REG(X) + 20] = ARG_REG(F);
			Syntax:  stmdb ARG_REG(X), {rA, rB, rC, rD, rE, rF}

		// Form 2:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg 0000 xxxx 0010
			// Effect:  
				// ARG_REG(X) -= 28;
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// [ARG_REG(X) + 16] = ARG_REG(E);
				// [ARG_REG(X) + 20] = ARG_REG(F);
				// [ARG_REG(X) + 24] = ARG_REG(G);
			Syntax:  stmdb ARG_REG(X), {rA, rB, rC, rD, rE, rF, rG}

		// Form 3:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh xxxx 0011
			// Effect:  
				// ARG_REG(X) -= 32;
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// [ARG_REG(X) + 16] = ARG_REG(E);
				// [ARG_REG(X) + 20] = ARG_REG(F);
				// [ARG_REG(X) + 24] = ARG_REG(G);
				// [ARG_REG(X) + 28] = ARG_REG(H);
			Syntax:  stmdb ARG_REG(X), {rA, rB, rC, rD, rE, rF, rG, rH}



		// LoaD Multiple, Increment After
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee 0000  0000 0000 xxxx 0000
			// Effect:  
				// ARG_REG(A) = [ARG_REG(X)]; 
				// ARG_REG(B) = [ARG_REG(X) + 4];
				// ARG_REG(C) = [ARG_REG(X) + 8];
				// ARG_REG(D) = [ARG_REG(X) + 12];
				// ARG_REG(E) = [ARG_REG(X) + 16];
				// ARG_REG(X) += 20;
			Syntax:  ldmia ARG_REG(X), {rA, rB, rC, rD, rE}

		// Form 1:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  0000 0000 xxxx 0001
			// Effect:  
				// ARG_REG(A) = [ARG_REG(X)]; 
				// ARG_REG(B) = [ARG_REG(X) + 4];
				// ARG_REG(C) = [ARG_REG(X) + 8];
				// ARG_REG(D) = [ARG_REG(X) + 12];
				// ARG_REG(E) = [ARG_REG(X) + 16];
				// ARG_REG(F) = [ARG_REG(X) + 20];
				// ARG_REG(X) += 24;
			Syntax:  ldmia ARG_REG(X), {rA, rB, rC, rD, rE, rF}

		// Form 2:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg 0000 xxxx 0010
			// Effect:  
				// ARG_REG(A) = [ARG_REG(X)]; 
				// ARG_REG(B) = [ARG_REG(X) + 4];
				// ARG_REG(C) = [ARG_REG(X) + 8];
				// ARG_REG(D) = [ARG_REG(X) + 12];
				// ARG_REG(E) = [ARG_REG(X) + 16];
				// ARG_REG(F) = [ARG_REG(X) + 20];
				// ARG_REG(G) = [ARG_REG(X) + 24];
				// ARG_REG(X) += 28;
			Syntax:  ldmia ARG_REG(X), {rA, rB, rC, rD, rE, rF, rG}

		// Form 3:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh xxxx 0011
			// Effect:  
				// ARG_REG(A) = [ARG_REG(X)]; 
				// ARG_REG(B) = [ARG_REG(X) + 4];
				// ARG_REG(C) = [ARG_REG(X) + 8];
				// ARG_REG(D) = [ARG_REG(X) + 12];
				// ARG_REG(E) = [ARG_REG(X) + 16];
				// ARG_REG(F) = [ARG_REG(X) + 20];
				// ARG_REG(G) = [ARG_REG(X) + 24];
				// ARG_REG(H) = [ARG_REG(X) + 28];
				// ARG_REG(X) += 32;
			Syntax:  ldmia ARG_REG(X), {rA, rB, rC, rD, rE, rF, rG, rH}


		// STore Multiple, Increment After
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee 0000  0000 0000 xxxx 0000
			// Effect:  
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// [ARG_REG(X) + 16] = ARG_REG(E);
				// ARG_REG(X) += 20;
			Syntax:  stmia ARG_REG(X), {rA, rB, rC, rD, rE}

		// Form 1:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  0000 0000 xxxx 0001
			// Effect:  
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// [ARG_REG(X) + 16] = ARG_REG(E);
				// [ARG_REG(X) + 20] = ARG_REG(F);
				// ARG_REG(X) += 24;
			Syntax:  stmia ARG_REG(X), {rA, rB, rC, rD, rE, rF}

		// Form 2:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg 0000 xxxx 0010
			// Effect:  
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// [ARG_REG(X) + 16] = ARG_REG(E);
				// [ARG_REG(X) + 20] = ARG_REG(F);
				// [ARG_REG(X) + 24] = ARG_REG(G);
				// ARG_REG(X) += 28;
			Syntax:  stmia ARG_REG(X), {rA, rB, rC, rD, rE, rF, rG}

		// Form 3:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh xxxx 0011
			// Effect:  
				// [ARG_REG(X)] = ARG_REG(A);
				// [ARG_REG(X) + 4] = ARG_REG(B);
				// [ARG_REG(X) + 8] = ARG_REG(C);
				// [ARG_REG(X) + 12] = ARG_REG(D);
				// [ARG_REG(X) + 16] = ARG_REG(E);
				// [ARG_REG(X) + 20] = ARG_REG(F);
				// [ARG_REG(X) + 24] = ARG_REG(G);
				// [ARG_REG(X) + 28] = ARG_REG(H);
				// ARG_REG(X) += 32;
			Syntax:  stmia ARG_REG(X), {rA, rB, rC, rD, rE, rF, rG, rH}

		// Unigned 32-bit by 32-bit Multiplication -> Unsigned 64-bit
		// result,
		// where rA is high 32 bits of result, rB is low 32 bits of result
		// $unsigned(rC * rD) -> rA:rB as a pair
		//
		// If rA and rB are the same register, only the low 32 bits of
		// result are stored
		umul rA:rB, rC, rD

		// Signed 32-bit by 32-bit Multiplication -> Signed 64-bit result,
		// where rA is high 32 bits of result, rB is low 32 bits of result
		// $signed(rC * rD) -> rA:rB as a pair
		//
		// If rA and rB are the same register, only the low 32 bits of
		// result are stored
		smul rA:rB, rC, rD


		// Unsigned 64-bit by 64-bit Division -> Unsigned 64-bit Quotient
		// and Unsigned 64-bit Remainder.
		// 
		// Unsigned Divides rE:rF by rG:rH, stores 64-bit unsigned quotient
		// in rA:rB and 64-bit unsigned remainder in rC:rD
		//
		// If rA and rB are the same register, only the low 32 bits of
		// quotient are stored
		//
		// If rC and rD are the same register, only the low 32 bits of the
		// remainder are stored.
		//
		// If rA is the same as either rC or rD, then no remainder will be
		// stored.
		//
		// If rB is the same as either rC or rD, then no remainder will be
		// stored.
		udivmod rA:rB, rC:rD, rE:rF, rG:rH

		// Signed 64-bit by 64-bit Division -> Signed 64-bit Quotient and
		// Signed 64-bit Remainder
		// 
		// Signed Divides rE:rF by rG:rH, stores 64-bit signed quotient in
		// rA:rB and 64-bit signed remainder in rC:rD
		//
		// If rA and rB are the same register, only the low 32 bits of
		// quotient are stored
		//
		// If rC and rD are the same register, only the low 32 bits of the
		// remainder are stored.
		//
		// If rA is the same as either rC or rD, then no remainder will be
		// stored.
		//
		// If rB is the same as either rC or rD, then no remainder will be
		// stored.
		sdivmod rA:rB, rC:rD, rE:rF, rG:rH

		// Unsigned 32-bit by 32-bit Division -> Unsigned 32-bit Quotient
		// and Unsigned 32-bit Remainder
		//
		// Unsigned Divides rC by rD, stores 32-bit unsigned quotient in rA
		// and 32-bit unsigned remainder in rB
		//
		// If rA is the same as rB, then no remainder will be stored.
		udivmod rA, rB, rC, rD

		// Signed 32-bit by 32-bit Division -> Signed 32-bit Quotient and
		// Signed 32-bit Remainder
		//
		// Signed Divides rC by rD, stores 32-bit signed quotient in rA and
		// 32-bit signed remainder in rB
		//
		// If rA is the same as rB, then no remainder will be stored.
		sdivmod rA, rB, rC, rD



		// 64-bit logical shift left by 64-bit register pair
		//
		// rA:rB = rC:rD << rE:rF
		//
		// if rA is the same register as rB, only the low 32 bits of the
		// result will be stored
		lsl rA:rB, rC:rD, rE:rF

		// 64-bit logical shift right by 64-bit register pair
		//
		// rA:rB = $unsigned($unsigned(rC:rD) >> $unsigned(rE:rF))
		//
		// if rA is the same register as rB, only the low 32 bits of the
		// result will be stored
		lsr rA:rB, rC:rD, rE:rF

		// 64-bit arithmetic shift right by 64-bit register pair
		//
		// rA:rB = $signed($signed(rC:rD) >> $signed(rE:rF))
		//
		// if rA is the same register as rB, only the low 32 bits of the
		// result will be stored
		asr rA:rB, rC:rD, rE:rF

		RESERVED



		RESERVED
		RESERVED
		RESERVED
		RESERVED




		RESERVED
		RESERVED
		RESERVED
		RESERVED




		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED



		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED

		RESERVED
		RESERVED
		RESERVED
		RESERVED



		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_REG(A) + ARG_ABS))
		//DESCRIBE_CALL_RETURN_ADDRESS
		DESCRIBE_PSEUDO_INSTR_ENCODING(calla,ARG_REG(A)\, ARG_REG(0)\, ARG_ABS)
		//INSTR_RA_IMM(calla,ARG_ABS)

		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_ABS))
		//DESCRIBE_CALL_RETURN_ADDRESS
		DESCRIBE_PSEUDO_INSTR_ENCODING(calla,ARG_REG(0)\, ARG_REG(0)\, ARG_ABS)
		//INSTR_IMM(calla,ARG_ABS)

		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A) + ARG_ABS))
		DESCRIBE_PSEUDO_INSTR_ENCODING(jumpa,ARG_REG(A)\, ARG_REG(0)\, ARG_ABS)
		//INSTR_RA_IMM(jumpa,ARG_ABS)

		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_ABS))
		DESCRIBE_PSEUDO_INSTR_ENCODING(jumpa,ARG_REG(0)\, ARG_REG(0)\, ARG_ABS)
		//INSTR_IMM(jumpa,ARG_ABS)


		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_REG(A) = 32-bit immediate
		DESCRIBE_PSEUDO_INSTR_ENCODING(cpypi,ARG_REG(A)\, ARG_REG(A)\, ARG_IMM)
		//INSTR_RA_IMM(cpyi,ARG_IMM)



		DESCRIBE_PSEUDO_INSTRUCTION
		// Pop
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee 0000  0000 0000 1111 0000
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(ldmia,ARG_SP\, {rA\, rB\, rC\, rD\, rE})
			// Effect:  
				// ARG_REG(A) = [ARG_SP]; 
				// ARG_REG(B) = [ARG_SP + 4];
				// ARG_REG(C) = [ARG_SP + 8];
				// ARG_REG(D) = [ARG_SP + 12];
				// ARG_REG(E) = [ARG_SP + 16];
				// ARG_SP += 20;
			// Syntax:  pop rA, rB, rC, rD, rE

		// Form 1:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  0000 0000 1111 0001
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(ldmia,ARG_SP\, {rA\, rB\, rC\, rD\, rE\, rF})
			// Effect:  
				// ARG_REG(A) = [ARG_SP]; 
				// ARG_REG(B) = [ARG_SP + 4];
				// ARG_REG(C) = [ARG_SP + 8];
				// ARG_REG(D) = [ARG_SP + 12];
				// ARG_REG(E) = [ARG_SP + 16];
				// ARG_REG(F) = [ARG_SP + 20];
				// ARG_SP += 24;
			// Syntax:  pop rA, rB, rC, rD, rE, rF

		// Form 2:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg 0000 1111 0010
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(ldmia,ARG_SP\, {rA\, rB\, rC\, rD\, rE\, rF\, rG})
			// Effect:  
				// ARG_REG(A) = [ARG_SP]; 
				// ARG_REG(B) = [ARG_SP + 4];
				// ARG_REG(C) = [ARG_SP + 8];
				// ARG_REG(D) = [ARG_SP + 12];
				// ARG_REG(E) = [ARG_SP + 16];
				// ARG_REG(F) = [ARG_SP + 20];
				// ARG_REG(G) = [ARG_SP + 24];
				// ARG_SP += 28;
			// Syntax:  pop rA, rB, rC, rD, rE, rF, rG

		// Form 3:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh 1111 0011
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(ldmia,ARG_SP\, {rA\, rB\, rC\, rD\, rE\, rF\, rG\, rH})
			// Effect:  
				// ARG_REG(A) = [ARG_SP]; 
				// ARG_REG(B) = [ARG_SP + 4];
				// ARG_REG(C) = [ARG_SP + 8];
				// ARG_REG(D) = [ARG_SP + 12];
				// ARG_REG(E) = [ARG_SP + 16];
				// ARG_REG(F) = [ARG_SP + 20];
				// ARG_REG(G) = [ARG_SP + 24];
				// ARG_REG(H) = [ARG_SP + 28];
				// ARG_SP += 32;
			// Syntax:  pop rA, rB, rC, rD, rE, rF, rG, rH


		DESCRIBE_PSEUDO_INSTRUCTION
		// Push
		// Note that this instruction takes multiple forms
		// Form 0:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee 0000  0000 0000 1111 0000
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(stmdb,ARG_SP\, {rA\, rB\, rC\, rD\, rE})
			// Effect:  
				// ARG_SP -= 20;
				// [ARG_SP] = ARG_REG(A);
				// [ARG_SP + 4] = ARG_REG(B);
				// [ARG_SP + 8] = ARG_REG(C);
				// [ARG_SP + 12] = ARG_REG(D);
				// [ARG_SP + 16] = ARG_REG(E);
			// Syntax:  push rA, rB, rC, rD, rE

		// Form 1:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  0000 0000 1111 0001
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(stmdb,ARG_SP\, {rA\, rB\, rC\, rD\, rE\, rF})
			// Effect:  
				// ARG_SP -= 24;
				// [ARG_SP] = ARG_REG(A);
				// [ARG_SP + 4] = ARG_REG(B);
				// [ARG_SP + 8] = ARG_REG(C);
				// [ARG_SP + 12] = ARG_REG(D);
				// [ARG_SP + 16] = ARG_REG(E);
				// [ARG_SP + 20] = ARG_REG(F);
			// Syntax:  push rA, rB, rC, rD, rE, rF

		// Form 2:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg 0000 1111 0010
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(stmdb,ARG_SP\, {rA\, rB\, rC\, rD\, rE\, rF\, rG})
			// Effect:  
				// ARG_SP -= 28;
				// [ARG_SP] = ARG_REG(A);
				// [ARG_SP + 4] = ARG_REG(B);
				// [ARG_SP + 8] = ARG_REG(C);
				// [ARG_SP + 12] = ARG_REG(D);
				// [ARG_SP + 16] = ARG_REG(E);
				// [ARG_SP + 20] = ARG_REG(F);
				// [ARG_SP + 24] = ARG_REG(G);
			// Syntax:  push rA, rB, rC, rD, rE, rF, rG

		// Form 3:
			// Encoding:  11oo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh 1111 0010
			DESCRIBE_PSEUDO_INSTR_ENCODING_2(stmdb,ARG_SP\, {rA\, rB\, rC\, rD\, rE\, rF\, rG\, rH})
			// Effect:  
				// ARG_SP -= 32;
				// [ARG_SP] = ARG_REG(A);
				// [ARG_SP + 4] = ARG_REG(B);
				// [ARG_SP + 8] = ARG_REG(C);
				// [ARG_SP + 12] = ARG_REG(D);
				// [ARG_SP + 16] = ARG_REG(E);
				// [ARG_SP + 20] = ARG_REG(F);
				// [ARG_SP + 24] = ARG_REG(G);
				// [ARG_SP + 28] = ARG_REG(H);
			// Syntax:  push rA, rB, rC, rD, rE, rF, rG, rH
