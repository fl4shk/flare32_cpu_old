`ifndef cpu_exec_instr_part_0_tasks_svinc
`define cpu_exec_instr_part_0_tasks_svinc


task exec_group_0_instr_part_0;
	// Load
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Ldr_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ldsb_LdStRaRb_0))
	begin
		prep_read(__instr_dec_out_buf.ldst_req_data_size, 
			__gprs[__instr_dec_out_buf.rb_index]);
	end

	// Store
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Str_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Stb_LdStRaRb_0))
	begin
		prep_write(__instr_dec_out_buf.ldst_req_data_size, 
			__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index]);
	end

	// Non flags affecting two-register ALU operation
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Add_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ror_RaRb_0))
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index],
			ig02_nf_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddDotF_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rrc_RaRb_0))
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index],
			ig02_f_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
	end

	// Enable/disable interrupts
	else if (__instr_dec_out_buf.oper == pkg_cpu::Eni_NoArgs_0)
	begin
		// Save doing this for the writeback stage
		//__spec_regs.ints_enabled <= 1;

		__temp[pkg_temp_ind::Ig0Eni_Ie] <= 1;
	end

	else if (__instr_dec_out_buf.oper == pkg_cpu::Dii_NoArgs_0)
	begin
		// Save doing this for the writeback stage
		//__spec_regs.ints_enabled <= 0;
		__temp[pkg_temp_ind::Ig0Dii_Ie] <= 0;
	end


	// Return from interrupt (enables interrupts in the process)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Reti_NoArgs_0)
	begin
		// Save doing this for the writeback stage
		//__spec_regs.pc <= __spec_regs.ira;
		//__spec_regs.ints_enabled <= 1;
		__temp[pkg_temp_ind::Ig0Reti_Ira] <= __spec_regs.ira;
		__temp[pkg_temp_ind::Ig0Reti_Ie]<= 1;
	end

	// Jump to the Interrupt Return Address without affecting the status of
	// whether interrupts are enabled
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jump_Ira_0)
	begin
		// Save doing this for the writeback stage
		//__spec_regs.pc <= __spec_regs.ira;
		//__temp[0] <= __spec_regs.ira;
		__temp[pkg_temp_ind::Ig0JumpIra_Ira] <= __spec_regs.ira;
	end

	// cpy rA, ira
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaIra_0)
	begin
		// Save doing this for the writeback stage
		// __gprs[__instr_dec_out_buf.ra_index] <= __spec_regs.ira;
		//__temp[0] <= __spec_regs.ira;
		__temp[pkg_temp_ind::Ig0CpyRaIra_Ira] <= __spec_regs.ira;
	end

	// cpy ira, rA
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_IraRa_0)
	begin
		// Save doing this for the writeback stage
		// __spec_regs.ira <= __gprs[__instr_dec_out_buf.ra_index];
		//__temp[0] <= __gprs[__instr_dec_out_buf.ra_index];
		__temp[pkg_temp_ind::Ig0CpyIraRa_RaIndex] 
			<= __gprs[__instr_dec_out_buf.ra_index];
	end


	// push/pop flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Push_Flags_0)
	begin
		
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Pop_Flags_0)
	begin
		
	end


	// cpy rA, flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaFlags_0)
	begin
		
	end

	// cpy flags, rA
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_FlagsRa_0)
	begin
		
	end

	// call/jump to address contained in (rA + rB)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Callx_RaRb_0)
	begin
		
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jumpx_RaRb_0)
	begin
		
	end

	// cpy rA, pc
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaPc_0)
	begin
		
	end

	// cpy rA, rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaRb_0)
	begin
		
	end

	// Sign extend
	else if (__instr_dec_out_buf.oper == pkg_cpu::Seh_RaRb_0)
	begin
		
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Seb_RaRb_0)
	begin
		
	end

	// Compare rA to rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cmp_RaRb_0)
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index], pkg_cpu::Alu_Sub);
	end
endtask

task exec_group_1_instr_part_0;
endtask

task exec_group_2_instr_part_0;
endtask

task exec_group_3_instr_part_0;
endtask


`endif		// cpu_exec_instr_part_0_tasks_svinc
