#define concat #1#2
#if 0

#endif
#define ONLY_FLAGS // This instruction ONLY affects flags.
#define FLAGS_NONE // This instruction does not affect flags.
#define FLAGS_N_AND_Z // This instruction affects the N and Z flags.
#define ONLY_Z // This instruction only affects the Z flag.
#define FLAGS_N_AND_Z_AND_C // This instruction affects N, Z, and C flags.
#define FLAGS_ALL // This instruction affects N, V, Z, and C flags.
#if 0


#endif
#define DESCRIBE_OP o:  opcode
#define DESCRIBE_RA a:  rA
#define DESCRIBE_RB b:  rB
#define DESCRIBE_RC c:  rc
#define DESCRIBE_IMM(x) i:  x-bit immediate value
#define DESCRIBE_IMM_UNSIGNED(x) DESCRIBE_IMM(zero-extended x)
#define DESCRIBE_IMM_SIGNED(x) DESCRIBE_IMM(sign-extended x)
#define DESCRIBE_INSTRUCTIONS Instructions:
#define DESCRIBE_PSEUDO_INSTRUCTION // Pseudo instruction:
#if 0


#endif
#define GROUP_HEADER(x) Group x Instructions
#if 0


#endif
#define ARG_REG(x) concat(r,x)
#define ARG_IMM imm
#define IMM_ZERO_EXTENDED (zero-extended ARG_IMM)
#define IMM_SIGN_EXTENDED (sign-extended ARG_IMM)
#define ARG_FOR_LDST_NON_INDEXED ARG_REG(B)
#define ARG_FOR_LDST_IMM_INDEXED(immediate) (ARG_FOR_LDST_NON_INDEXED + immediate)
#define ARG_FOR_LDST_GENERIC_INDEXED(immediate) (ARG_FOR_LDST_NON_INDEXED + ARG_REG(C) + immediate)
#define IGNORE_REG(x) // Note that ARG_REG(x) is ignored.
#if 0


#endif
#define INSTR_IMM( instr, immediate ) instr immediate
#define INSTR_RA(instr) instr ARG_REG(A)
#define INSTR_RA_IMM( instr, immediate ) INSTR_RA(instr), immediate
#define INSTR_RA_RB(instr) INSTR_RA(instr), ARG_REG(B)
#define INSTR_RA_RB_IMM( instr, immediate ) INSTR_RA_RB(instr), immediate
#define INSTR_RA_RB_RC(instr) INSTR_RA_RB(instr), ARG_REG(C)
#define INSTR_RA_RB_RC_IMM( instr, immediate ) INSTR_RA_RB_RC(instr), immediate
#define RESERVED // Reserved for future expansion.
#if 0


#endif
#define _DESCRIBE_LOAD_PART_1(x) // Load x-bit value from address in
#define _DESCRIBE_LOAD_US_PART_1( us, x ) // Load us x-bit value from address in
#define _DESCRIBE_LOAD_PART_2(arg_address) arg_address into ARG_REG(A)
#define DESCRIBE_LOAD_32(arg_address) _DESCRIBE_LOAD_PART_1(32) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_16_UNSIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(unsigned,16) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_16_SIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(signed,16) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_8_UNSIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(unsigned,8) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_8_SIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(signed,8) _DESCRIBE_LOAD_PART_2(arg_address)
#if 0


#endif
#define _DESCRIBE_ROTATE( lr, amount ) // Rotate ARG_REG(A) lr by amount
#define DESCRIBE_ROTATE_NOT_THROUGH_CARRY( lr, amount ) _DESCRIBE_ROTATE(lr (NOT through carry),amount bits).
#define DESCRIBE_ROTATE_THROUGH_CARRY(lr) _DESCRIBE_ROTATE(lr (THROUGH carry),1 bit), ignoring ARG_REG(B).
#if 0


#endif
#define DESCRIBE_ZERO_EXTEND // This zero extends the value.
#define DESCRIBE_SIGN_EXTEND // This sign extends the value.
#if 0


#endif
#define DESCRIBE_BRANCH_TARGET to (pc when instruction starts) + (sign extended 16-bit immediate value)
#if 0


#endif
#define _DESCRIBE_STORE( x, arg_address ) // Store x ARG_REG(A) to address in arg_address
#define DESCRIBE_STORE_32(arg_address) _DESCRIBE_STORE(32-bit value in,arg_address)
#define DESCRIBE_STORE_16(arg_address) _DESCRIBE_STORE(low 16 bits of,arg_address)
#define DESCRIBE_STORE_8(arg_address) _DESCRIBE_STORE(low 8 bits of,arg_address)
#if 0

You won't see this sentence in the final .txt file.
It's nice, I guess

#endif
Three instruction encoding sizes:  16-bit, 32-bit, and 48-bit

The instruction group is a 4-bit field, the 4 most significant bits of the
first 16-bits.

Group 0 Instructions, for example, use 0000 as their group identifier.

GROUP_HEADER(0)
000o oooo aaaa bbbb
	
	DESCRIBE_OP
	DESCRIBE_RA (destination register usually)
	DESCRIBE_RB
	
	DESCRIBE_INSTRUCTIONS
		FLAGS_ALL
		INSTR_RA_RB(add)
		
		// Add with carry
		FLAGS_ALL
		INSTR_RA_RB(adc)
		
		FLAGS_ALL
		INSTR_RA_RB(sub)
		
		// Subtract with borrow (6502 style)
		FLAGS_ALL
		INSTR_RA_RB(sbc)
		
		
		
		ONLY_FLAGS
		INSTR_RA_RB(cmp)
		
		// Logical shift left
		FLAGS_N_AND_Z
		INSTR_RA_RB(lsl)
		
		// Logical shift right
		FLAGS_N_AND_Z
		INSTR_RA_RB(lsr)
		
		// Arithmetic shift right
		FLAGS_N_AND_Z
		INSTR_RA_RB(asr)
		
		
		
		FLAGS_N_AND_Z
		INSTR_RA_RB(and)
		
		FLAGS_N_AND_Z
		INSTR_RA_RB(or)
		
		FLAGS_N_AND_Z
		INSTR_RA_RB(xor)
		
		// ARG_REG(A) *= ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(mul)
		
		
		
		DESCRIBE_ROTATE_NOT_THROUGH_CARRY(left,ARG_REG(B))
		FLAGS_N_AND_Z
		INSTR_RA_RB(rol)
		
		DESCRIBE_ROTATE_NOT_THROUGH_CARRY(right,ARG_REG(B))
		FLAGS_N_AND_Z
		INSTR_RA_RB(ror)
		
		DESCRIBE_ROTATE_THROUGH_CARRY(left)
		FLAGS_N_AND_Z_AND_C
		IGNORE_REG(B)
		INSTR_RA(rlc)
		
		DESCRIBE_ROTATE_THROUGH_CARRY(right)
		FLAGS_N_AND_Z_AND_C
		IGNORE_REG(B)
		INSTR_RA(rrc)
		
		
		
		
		
		DESCRIBE_LOAD_32(ARG_FOR_LDST_NON_INDEXED)
		FLAGS_NONE
		INSTR_RA_RB(ldr)
		
		DESCRIBE_LOAD_16_UNSIGNED(ARG_FOR_LDST_NON_INDEXED)
		DESCRIBE_ZERO_EXTEND
		FLAGS_NONE
		INSTR_RA_RB(ldh)
		
		DESCRIBE_LOAD_16_SIGNED(ARG_FOR_LDST_NON_INDEXED)
		DESCRIBE_SIGN_EXTEND
		FLAGS_NONE
		INSTR_RA_RB(ldsh)
		
		DESCRIBE_LOAD_8_UNSIGNED(ARG_FOR_LDST_NON_INDEXED)
		DESCRIBE_ZERO_EXTEND
		FLAGS_NONE
		INSTR_RA_RB(ldb)
		
		
		
		DESCRIBE_LOAD_8_SIGNED(ARG_FOR_LDST_NON_INDEXED)
		DESCRIBE_SIGN_EXTEND
		FLAGS_NONE
		INSTR_RA_RB(ldsb)
		
		DESCRIBE_STORE_32(ARG_FOR_LDST_NON_INDEXED)
		FLAGS_NONE
		INSTR_RA_RB(str)
		
		DESCRIBE_STORE_16(ARG_FOR_LDST_NON_INDEXED)
		FLAGS_NONE
		INSTR_RA_RB(sth)
		
		DESCRIBE_STORE_8(ARG_FOR_LDST_NON_INDEXED)
		FLAGS_NONE
		INSTR_RA_RB(stb)
		
		
		
		// ARG_REG(A) = Zero extend of low 8 bits in ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(zeb)
		
		// ARG_REG(A) = Sign extend of low 8 bits in ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(seb)
		
		// ARG_REG(A) = Zero extend of low 16 bits in ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(zeh)
		
		// ARG_REG(A) = Sign extend of low 16 bits in ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(seh)
		
		
		
		// Copy (ARG_REG(A) = ARG_REG(B))
		FLAGS_NONE
		INSTR_RA_RB(cpy)
		
		// Copy Negated (ARG_REG(A) = -ARG_REG(B))
		FLAGS_NONE
		INSTR_RA_RB(cpn)
		
		// Copy Complemented (ARG_REG(A) = ~ARG_REG(B))
		FLAGS_NONE
		INSTR_RA_RB(cpc)
		
		// Swap (temp = ARG_REG(A); ARG_REG(A) = ARG_REG(B); ARG_REG(B) = temp)
		// Not sure how useful this is, but you can swap with the stack
		// pointer or with the link register
		FLAGS_NONE
		INSTR_RA_RB(swp)

GROUP_HEADER(1)
001o oooo aaaa bbbb
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	
	DESCRIBE_INSTRUCTIONS
		// ARG_REG(A) = ARG_REG(B) + 1
		FLAGS_ALL
		INSTR_RA_RB(inc)
		
		// ARG_REG(A) = ARG_REG(B) - 1
		FLAGS_ALL
		INSTR_RA_RB(dec)
		
		// ARG_REG(A):ARG_REG(B) = (64-bit zero extend of ARG_REG(A)) * (64-bit zero extend of ARG_REG(B))
		// Note that ARG_REG(A) will contain the high 32 bits of the unsigned 64-bit product
		// Note that ARG_REG(B) will contain the low 32 bits of the unsigned 64-bit product
		FLAGS_NONE
		INSTR_RA_RB(umull)
		
		// ARG_REG(A):ARG_REG(B) = (64-bit sign extend of ARG_REG(A)) * (64-bit sign extend of ARG_REG(B))
		// Note that ARG_REG(A) will contain the high 32 bits of the signed 64-bit product
		// Note that ARG_REG(B) will contain the low 32 bits of the signed 64-bit product
		FLAGS_NONE
		INSTR_RA_RB(smull)
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED


GROUP_HEADER(2)
010o oooo aaaa bbbb iiii iiii iiii iiii
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_IMM(16)
	
	DESCRIBE_INSTRUCTIONS
		DESCRIBE_LOAD_32(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		FLAGS_NONE
		INSTR_RA_RB_IMM(ldrxi,ARG_IMM)
		
		DESCRIBE_LOAD_16_UNSIGNED(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		FLAGS_NONE
		INSTR_RA_RB_IMM(ldhxi,ARG_IMM)
		
		DESCRIBE_LOAD_16_SIGNED(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		FLAGS_NONE
		INSTR_RA_RB_IMM(ldshxi,ARG_IMM)
		
		DESCRIBE_LOAD_8_UNSIGNED(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		FLAGS_NONE
		INSTR_RA_RB_IMM(ldbxi,ARG_IMM)
		
		
		
		DESCRIBE_LOAD_8_SIGNED(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		FLAGS_NONE
		INSTR_RA_RB_IMM(ldsbxi,ARG_IMM)
		
		DESCRIBE_STORE_32(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		FLAGS_NONE
		INSTR_RA_RB_IMM(strxi,ARG_IMM)
		
		DESCRIBE_STORE_16(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		FLAGS_NONE
		INSTR_RA_RB_IMM(sthxi,ARG_IMM)
		
		DESCRIBE_STORE_8(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		FLAGS_NONE
		INSTR_RA_RB_IMM(stbxi,ARG_IMM)
		
		
		
		// ARG_REG(A) low 16 bits = ARG_IMM
		FLAGS_NONE
		IGNORE_REG(B)
		INSTR_RA_IMM(cpyloi,ARG_IMM)
		
		// ARG_REG(A) high 16 bits = ARG_IMM
		FLAGS_NONE
		IGNORE_REG(B)
		INSTR_RA_IMM(cpyhii,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) + IMM_SIGN_EXTENDED
		FLAGS_ALL
		INSTR_RA_RB_IMM(addsi,ARG_IMM)
		
		// Logical shift left, by IMM_ZERO_EXTENDED bits
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(lsli,ARG_IMM)
		
		
		
		// Logical shift right, by IMM_ZERO_EXTENDED bits
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(lsri,ARG_IMM)
		
		// Arithmetic shift right, by IMM_ZERO_EXTENDED bits
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(asri,ARG_IMM)
		
		// Rotate ARG_REG(A) left (NOT through carry) by IMM_ZERO_EXTENDED
		// bits, ignoring ARG_REG(B)
		INSTR_RA_IMM(roli,ARG_IMM)
		
		// Rotate ARG_REG(A) right (NOT through carry) by IMM_ZERO_EXTENDED
		// bits, ignoring ARG_REG(B)
		INSTR_RA_IMM(rori,ARG_IMM)
		
		
		
		
		// aaaa
		INSTR_IMM(GGGGG,ARG_IMM)
		
		// Branch always, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bra,ARG_IMM)
		
		// Branch when Z == 0, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bne,ARG_IMM)
		
		// Branch when Z == 1, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(beq,ARG_IMM)
		
		
		
		// Branch when C == 0 [unsigned less than], DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bcc,ARG_IMM)
		
		// Branch when C == 1 [unsigned greater than or equal], DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bcs,ARG_IMM)
		
		// Branch when ( C == 0 or Z == 1 ) [unsigned less than or equal], DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bls,ARG_IMM)
		
		// Branch when ( C == 1 and Z == 0 ) [unsigned greater than], DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bhi,ARG_IMM)
		
		
		
		// Branch when N == 0, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bpl,ARG_IMM)
		
		// Branch when N == 1, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bmi,ARG_IMM)
		
		// Branch when V == 0, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bvc,ARG_IMM)
		
		// Branch when V == 1, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bvs,ARG_IMM)
		
		
		
		// Branch when N == V [signed greater than or equal], DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bge,ARG_IMM)
		
		// Branch when N != V [signed less than], DESCRIBE_BRANCH_TARGET
		INSTR_IMM(blt,ARG_IMM)
		
		// Branch when ( N == V and Z == 0 ) [signed greater than], DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bgt,ARG_IMM)
		
		// Branch when ( N != V or Z == 1 ) [signed less than or equal], DESCRIBE_BRANCH_TARGET
		INSTR_IMM(ble,ARG_IMM)
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_REG(A) = ARG_REG(B) - IMM_SIGN_EXTENDED
		//FLAGS_ALL
		//INSTR_RA_RB_IMM(subsi,ARG_IMM)
		
