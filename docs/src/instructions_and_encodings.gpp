#define concat #1#2
#if 0

#endif
#define ONLY_FLAGS // This instruction ONLY affects flags.
#define FLAGS_NONE // This instruction does not affect flags.
#define FLAGS_N_AND_Z // This instruction affects the N and Z flags.
#define ONLY_Z // This instruction only affects the Z flag.
#define FLAGS_N_AND_Z_AND_C // This instruction affects N, Z, and C flags.
#define FLAGS_ALL // This instruction affects N, V, Z, and C flags.
#if 0


#endif
#define DESCRIBE_OP o:  opcode
#define DESCRIBE_RA a:  rA
#define DESCRIBE_RB b:  rB
#define DESCRIBE_RC c:  rc
#define DESCRIBE_IMM(x) i:  x-bit immediate value
#define DESCRIBE_IMM_UNSIGNED(x) DESCRIBE_IMM(zero-extended x)
#define DESCRIBE_IMM_SIGNED(x) DESCRIBE_IMM(sign-extended x)
#define DESCRIBE_INSTRUCTIONS Instructions:
#define DESCRIBE_PSEUDO_INSTRUCTION // Pseudo instruction:
#if 0


#endif
#define _DESCRIBE_LOAD_PART_1(x) // Load x-bit value from address in
#define _DESCRIBE_LOAD_US_PART_1( us, x ) // Load us x-bit value from address in
#define _DESCRIBE_LOAD_PART_2(arg_address) arg_address into ARG_REG(A)
#define DESCRIBE_LOAD_32(arg_address) _DESCRIBE_LOAD_PART_1(32) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_16_UNSIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(zero-extended,16) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_16_SIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(sign-extended,16) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_8_UNSIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(zero-extended,8) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_8_SIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(sign-extended,8) _DESCRIBE_LOAD_PART_2(arg_address)
#if 0


#endif
#define _DESCRIBE_STORE( x, arg_address ) // Store x ARG_REG(A) to address in arg_address
#define DESCRIBE_STORE_32(arg_address) _DESCRIBE_STORE(32-bit value in,arg_address)
#define DESCRIBE_STORE_16(arg_address) _DESCRIBE_STORE(low 16 bits of,arg_address)
#define DESCRIBE_STORE_8(arg_address) _DESCRIBE_STORE(low 8 bits of,arg_address)
#if 0


#endif
#define _DESCRIBE_ROTATE( lr, amount ) // Rotate ARG_REG(A) lr by amount
#define DESCRIBE_ROTATE_NOT_THROUGH_CARRY( lr, amount ) _DESCRIBE_ROTATE(lr (NOT through carry),amount bits).
#define DESCRIBE_ROTATE_THROUGH_CARRY(lr) _DESCRIBE_ROTATE(lr (THROUGH carry),1 bit), ignoring ARG_REG(B).
#if 0


#endif
#define DESCRIBE_ZERO_EXTEND // This zero-extends the value.
#define DESCRIBE_SIGN_EXTEND // This sign-extends the value.
#if 0


#endif
#define DESCRIBE_JUMP_DESTINATION_ADDRESS(addr) // Set pc to destination address in addr.
#define DESCRIBE_CALL_DESTINATION_ADDRESS(addr) // Subroutine call using addr as destination address. 
#define DESCRIBE_CALL_RETURN_ADDRESS // The return address is stored in the link register (lr).
#define DESCRIBE_BRANCH_TARGET to (pc when instruction starts) + (sign-extended 16-bit immediate value)
#if 0


#endif
#define GROUP_HEADER(x) Group x Instructions
#if 0


#endif
#define ARG_REG(x) concat(r,x)
#define ARG_IMM imm
#define IMM_ZERO_EXTENDED (zero-extended ARG_IMM)
#define IMM_SIGN_EXTENDED (sign-extended ARG_IMM)
#define ARG_FOR_LDST_NON_INDEXED ARG_REG(B)
#define ARG_FOR_LDST_IMM_INDEXED(immediate) (ARG_FOR_LDST_NON_INDEXED + immediate)
#define ARG_FOR_LDST_GENERIC_INDEXED(immediate) (ARG_FOR_LDST_NON_INDEXED + ARG_REG(C) + immediate)
#define IGNORE_REG(x) // Note that ARG_REG(x) is ignored.
#if 0


#endif
#define INSTR_NO_ARGS(instr) instr
#define INSTR_IMM( instr, immediate ) instr immediate
#define INSTR_RA(instr) instr ARG_REG(A)
#define INSTR_RA_IMM( instr, immediate ) INSTR_RA(instr), immediate
#define INSTR_RA_RB(instr) INSTR_RA(instr), ARG_REG(B)
#define INSTR_RA_RB_IMM( instr, immediate ) INSTR_RA_RB(instr), immediate
#define INSTR_RA_RB_RC(instr) INSTR_RA_RB(instr), ARG_REG(C)
#define INSTR_RA_RB_RC_IMM( instr, immediate ) INSTR_RA_RB_RC(instr), immediate
#define RESERVED // Reserved for future expansion.
#if 0

You won't see this sentence in the final .txt file.
It's nice, I guess

#endif
Three instruction encoding sizes:  16-bit, 32-bit, and 48-bit

The instruction group is a 3-bit field, the 3 most significant bits of the
first 16-bits.

Group 0 Instructions, for example, use 000 as their group identifier.

GROUP_HEADER(0)
000o oooo aaaa bbbb
	
	DESCRIBE_OP
	DESCRIBE_RA (destination register usually)
	DESCRIBE_RB
	
	DESCRIBE_INSTRUCTIONS
		FLAGS_ALL
		INSTR_RA_RB(add)
		
		// Add with carry
		FLAGS_ALL
		INSTR_RA_RB(adc)
		
		FLAGS_ALL
		INSTR_RA_RB(sub)
		
		// Subtract with borrow (6502 style)
		FLAGS_ALL
		INSTR_RA_RB(sbc)
		
		
		
		ONLY_FLAGS
		INSTR_RA_RB(cmp)
		
		// Logical shift left
		FLAGS_N_AND_Z
		INSTR_RA_RB(lsl)
		
		// Logical shift right
		FLAGS_N_AND_Z
		INSTR_RA_RB(lsr)
		
		// Arithmetic shift right
		FLAGS_N_AND_Z
		INSTR_RA_RB(asr)
		
		
		
		FLAGS_N_AND_Z
		INSTR_RA_RB(and)
		
		FLAGS_N_AND_Z
		INSTR_RA_RB(or)
		
		FLAGS_N_AND_Z
		INSTR_RA_RB(xor)
		
		// ARG_REG(A) *= ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(mul)
		
		
		
		DESCRIBE_ROTATE_NOT_THROUGH_CARRY(left,ARG_REG(B))
		FLAGS_N_AND_Z
		INSTR_RA_RB(rol)
		
		DESCRIBE_ROTATE_NOT_THROUGH_CARRY(right,ARG_REG(B))
		FLAGS_N_AND_Z
		INSTR_RA_RB(ror)
		
		DESCRIBE_ROTATE_THROUGH_CARRY(left)
		FLAGS_N_AND_Z_AND_C
		INSTR_RA(rlc)
		
		DESCRIBE_ROTATE_THROUGH_CARRY(right)
		FLAGS_N_AND_Z_AND_C
		INSTR_RA(rrc)
		
		
		
		DESCRIBE_LOAD_32(ARG_FOR_LDST_NON_INDEXED)
		INSTR_RA_RB(ldr)
		
		DESCRIBE_LOAD_16_UNSIGNED(ARG_FOR_LDST_NON_INDEXED)
		DESCRIBE_ZERO_EXTEND
		INSTR_RA_RB(ldh)
		
		DESCRIBE_LOAD_16_SIGNED(ARG_FOR_LDST_NON_INDEXED)
		DESCRIBE_SIGN_EXTEND
		INSTR_RA_RB(ldsh)
		
		DESCRIBE_LOAD_8_UNSIGNED(ARG_FOR_LDST_NON_INDEXED)
		DESCRIBE_ZERO_EXTEND
		INSTR_RA_RB(ldb)
		
		
		
		DESCRIBE_LOAD_8_SIGNED(ARG_FOR_LDST_NON_INDEXED)
		DESCRIBE_SIGN_EXTEND
		INSTR_RA_RB(ldsb)
		
		DESCRIBE_STORE_32(ARG_FOR_LDST_NON_INDEXED)
		INSTR_RA_RB(str)
		
		DESCRIBE_STORE_16(ARG_FOR_LDST_NON_INDEXED)
		INSTR_RA_RB(sth)
		
		DESCRIBE_STORE_8(ARG_FOR_LDST_NON_INDEXED)
		INSTR_RA_RB(stb)
		
		
		
		// ARG_REG(A) = Zero extend of low 16 bits in ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(zeh)
		
		// ARG_REG(A) = Sign extend of low 16 bits in ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(seh)
		
		// ARG_REG(A) = Zero extend of low 8 bits in ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(zeb)
		
		// ARG_REG(A) = Sign extend of low 8 bits in ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(seb)
		
		
		
		// Copy (ARG_REG(A) = ARG_REG(B))
		INSTR_RA_RB(cpy)
		
		// Copy Negated (ARG_REG(A) = -ARG_REG(B))
		INSTR_RA_RB(cpn)
		
		// Copy Complemented (ARG_REG(A) = ~ARG_REG(B))
		INSTR_RA_RB(cpc)
		
		// Copy pc to ARG_REG(A) (this can be used for pc-relative loads
		// and stores)
		FLAGS_N_AND_Z
		INSTR_RA(cpyfrpc)


GROUP_HEADER(1)
001o oooo aaaa bbbb
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	
	DESCRIBE_INSTRUCTIONS
		// ARG_REG(A) = ARG_REG(B) + 1
		FLAGS_ALL
		INSTR_RA_RB(inc)
		
		// ARG_REG(A) = ARG_REG(B) - 1
		FLAGS_ALL
		INSTR_RA_RB(dec)
		
		// ARG_REG(A):ARG_REG(B) = (64-bit zero-extend of ARG_REG(A)) * (64-bit zero-extend of ARG_REG(B))
		// 
		// Note that ARG_REG(A) will contain the high 32 bits of the 
		// unsigned 64-bit product
		// 
		// Note that ARG_REG(B) will contain the low 32 bits of the 
		// unsigned 64-bit product
		// 
		INSTR_RA_RB(umull)
		
		// ARG_REG(A):ARG_REG(B) = (64-bit sign-extend of ARG_REG(A)) * (64-bit sign-extend of ARG_REG(B))
		// 
		// Note that ARG_REG(A) will contain the high 32 bits of the signed 
		// 64-bit product
		// 
		// Note that ARG_REG(B) will contain the low 32 bits of the signed 
		// 64-bit product
		// 
		INSTR_RA_RB(smull)
		
		
		
		DESCRIBE_JUMP_DESTINATION_ADDRESS(ARG_REG(A))
		INSTR_RA(jump)
		
		DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B)))
		INSTR_RA_RB(jumpx)
		
		DESCRIBE_CALL_DESTINATION_ADDRESS(ARG_REG(A))
		DESCRIBE_CALL_RETURN_ADDRESS
		INSTR_RA(call)
		
		DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B)))
		DESCRIBE_CALL_RETURN_ADDRESS
		INSTR_RA_RB(callx)
		
		
		
		// Push register ARG_REG(A) onto the stack
		INSTR_RA(pushr)
		
		// Pop 32-bit value off the stack into ARG_REG(A)
		INSTR_RA(popr)
		
		// Push registers ARG_REG(A) and ARG_REG(b) (as a pair) onto the 
		// stack (in that order)
		INSTR_RA_RB(pushp)
		
		// Pop two 32-bit values off the stack, storing the first popped
		// value into ARG_REG(B) and the second popped value into ARG_REG(A)
		INSTR_RA_RB(popp)
		
		
		
		// Swap the Interrupt Return Address and ARG_REG(A)
		FLAGS_N_AND_Z
		INSTR_RA(swpira)
		
		// Copy the Interrupt Return Address to ARG_REG(A)
		FLAGS_N_AND_Z
		INSTR_RA(cpyira)
		
		// Clear ARG_REG(A), then CoPY FRom Flags to ARG_REG(A)
		INSTR_RA(cpyfrf)
		
		// Copy to flags from ARG_REG(A)
		FLAGS_ALL
		INSTR_RA(cpytof)
		
		
		
		// ENable Interrupts
		INSTR_NO_ARGS(eni)
		
		// DIsable Interrupts
		INSTR_NO_ARGS(dii)
		
		// Set the PC to interrupt RETurn address and enable Interrupts
		INSTR_NO_ARGS(reti)
		
		// Set the PC to the Interrupt Return Address, but DON'T enable
		// interrupts
		INSTR_NO_ARGS(jumpira)
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED


GROUP_HEADER(2)
010o oooo aaaa bbbb iiii iiii iiii iiii
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_IMM(16)
	
	DESCRIBE_INSTRUCTIONS
		DESCRIBE_LOAD_32(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_IMM(ldrxi,ARG_IMM)
		
		DESCRIBE_LOAD_16_UNSIGNED(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_IMM(ldhxi,ARG_IMM)
		
		DESCRIBE_LOAD_16_SIGNED(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_IMM(ldshxi,ARG_IMM)
		
		DESCRIBE_LOAD_8_UNSIGNED(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_IMM(ldbxi,ARG_IMM)
		
		
		
		DESCRIBE_LOAD_8_SIGNED(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_IMM(ldsbxi,ARG_IMM)
		
		DESCRIBE_STORE_32(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_IMM(strxi,ARG_IMM)
		
		DESCRIBE_STORE_16(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_IMM(sthxi,ARG_IMM)
		
		DESCRIBE_STORE_8(ARG_FOR_LDST_IMM_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_IMM(stbxi,ARG_IMM)
		
		
		
		// ARG_REG(A) low 16 bits = ARG_IMM
		INSTR_RA_IMM(cpyloi,ARG_IMM)
		
		// ARG_REG(A) high 16 bits = ARG_IMM
		INSTR_RA_IMM(cpyhii,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) + IMM_SIGN_EXTENDED
		FLAGS_ALL
		INSTR_RA_RB_IMM(addsi,ARG_IMM)
		
		// Logical shift left, by IMM_ZERO_EXTENDED bits
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(lsli,ARG_IMM)
		
		
		
		// Logical shift right, by IMM_ZERO_EXTENDED bits
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(lsri,ARG_IMM)
		
		// Arithmetic shift right, by IMM_ZERO_EXTENDED bits
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(asri,ARG_IMM)
		
		DESCRIBE_ROTATE_NOT_THROUGH_CARRY(left,ARG_REG(B))
		INSTR_RA_IMM(roli,ARG_IMM)
		
		DESCRIBE_ROTATE_NOT_THROUGH_CARRY(right,ARG_REG(B))
		INSTR_RA_IMM(rori,ARG_IMM)
		
		
		
		// Compare ARG_REG(A) to IMM_ZERO_EXTENDED
		ONLY_FLAGS
		INSTR_IMM(cmpi,ARG_IMM)
		
		// Branch always, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bra,ARG_IMM)
		
		// Branch when Z == 0, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bne,ARG_IMM)
		
		// Branch when Z == 1, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(beq,ARG_IMM)
		
		
		
		// Branch when C == 0 [unsigned less than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bcc,ARG_IMM)
		
		// Branch when C == 1 [unsigned greater than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bcs,ARG_IMM)
		
		// Branch when ( C == 0 or Z == 1 ) [unsigned less than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bls,ARG_IMM)
		
		// Branch when ( C == 1 and Z == 0 ) [unsigned greater than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bhi,ARG_IMM)
		
		
		
		// Branch when N == 0, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bpl,ARG_IMM)
		
		// Branch when N == 1, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bmi,ARG_IMM)
		
		// Branch when V == 0, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bvc,ARG_IMM)
		
		// Branch when V == 1, DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bvs,ARG_IMM)
		
		
		
		// Branch when N == V [signed greater than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bge,ARG_IMM)
		
		// Branch when N != V [signed less than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(blt,ARG_IMM)
		
		// Branch when ( N == V and Z == 0 ) [signed greater than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bgt,ARG_IMM)
		
		// Branch when ( N != V or Z == 1 ) [signed less than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(ble,ARG_IMM)
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_REG(A) = ARG_REG(B) - IMM_SIGN_EXTENDED
		//FLAGS_ALL
		//INSTR_RA_RB_IMM(subsi,ARG_IMM)


GROUP_HEADER(3)
011o oooo aaaa bbbb cccc iiii iiii iiii
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_IMM(12)
	
	DESCRIBE_INSTRUCTIONS
		DESCRIBE_LOAD_32(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_RC_IMM(ldrxx,ARG_IMM)
		
		DESCRIBE_LOAD_16_UNSIGNED(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_RC_IMM(ldhxx,ARG_IMM)
		
		DESCRIBE_LOAD_16_SIGNED(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_RC_IMM(ldshxx,ARG_IMM)
		
		DESCRIBE_LOAD_8_UNSIGNED(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_RC_IMM(ldbxx,ARG_IMM)
		
		
		
		DESCRIBE_LOAD_8_SIGNED(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_RC_IMM(ldsbxx,ARG_IMM)
		
		DESCRIBE_STORE_32(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_RC_IMM(strxx,ARG_IMM)
		
		DESCRIBE_STORE_16(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_RC_IMM(sthxx,ARG_IMM)
		
		DESCRIBE_STORE_8(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED))
		INSTR_RA_RB_RC_IMM(stbxx,ARG_IMM)
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
	
