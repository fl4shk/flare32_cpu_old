Three instruction encoding sizes:  16-bit, 32-bit, and 48-bit

The instruction group is a 4-bit field, the 4 most significant bits of the
first 16-bits.

Group 0 Instructions, for example, use 0000 as their group identifier.

Group 0 Instructions
0000 oooo aaaa bbbb
	
	o:  opcode
	a:  rA (destination register usually)
	b:  rB
	
	Instructions:
		// This instruction affects N, V, Z, and C flags.
		add rA, rB
		
		// Add with carry
		// This instruction affects N, V, Z, and C flags.
		adc rA, rB
		
		// This instruction affects N, V, Z, and C flags.
		sub rA, rB
		
		// Subtract with borrow (6502 style)
		// This instruction affects N, V, Z, and C flags.
		sbc rA, rB
		
		
		
		// This instruction ONLY affects flags.
		cmp rA, rB
		
		// Logical shift left
		// This instruction affects the N and Z flags.
		lsl rA, rB
		
		// Logical shift right
		// This instruction affects the N and Z flags.
		lsr rA, rB
		
		// Arithmetic shift right
		// This instruction affects the N and Z flags.
		asr rA, rB
		
		
		
		// This instruction affects the N and Z flags.
		and rA, rB
		
		// This instruction affects the N and Z flags.
		or rA, rB
		
		// This instruction affects the N and Z flags.
		xor rA, rB
		
		// rA *= rB
		// This instruction affects the N and Z flags.
		mul rA, rB
		
		
		
		// Rotate rA left (NOT through carry) by rB bits.
		// This instruction affects the N and Z flags.
		rol rA, rB
		
		// Rotate rA right (NOT through carry) by rB bits.
		// This instruction affects the N and Z flags.
		ror rA, rB
		
		// Rotate rA left (THROUGH carry) by 1 bit, ignoring rB.
		// This instruction affects N, Z, and C flags.
		// Note that rB is ignored.
		rlc rA
		
		// Rotate rA right (THROUGH carry) by 1 bit, ignoring rB.
		// This instruction affects N, Z, and C flags.
		// Note that rB is ignored.
		rrc rA


Group 1 Instructions
0001 oooo aaaa bbbb
	
	o:  opcode
	a:  rA
	b:  rB
	
	Instructions:
		// Load 32-bit value from address in rB into rA
		// This instruction does not affect flags.
		ldr rA, rB
		
		// Load unsigned 16-bit value from address in rB into rA
		// This zero extends the value.
		// This instruction does not affect flags.
		ldh rA, rB
		
		// Load signed 16-bit value from address in rB into rA
		// This sign extends the value.
		// This instruction does not affect flags.
		ldsh rA, rB
		
		// Load unsigned 8-bit value from address in rB into rA
		// This zero extends the value.
		// This instruction does not affect flags.
		ldb rA, rB
		
		
		
		// Load signed 8-bit value from address in rB into rA
		// This sign extends the value.
		// This instruction does not affect flags.
		ldsb rA, rB
		
		// Store 32-bit value in rA to address in rB
		// This instruction does not affect flags.
		str rA, rB
		
		// Store low 16 bits of rA to address in rB
		// This instruction does not affect flags.
		sth rA, rB
		
		// Store low 8 bits of rA to address in rB
		// This instruction does not affect flags.
		stb rA, rB
		
		
		
		// rA = Zero extend of low 8 bits in rB
		// This instruction affects the N and Z flags.
		zeb rA, rB
		
		// rA = Sign extend of low 8 bits in rB
		// This instruction affects the N and Z flags.
		seb rA, rB
		
		// rA = Zero extend of low 16 bits in rB
		// This instruction affects the N and Z flags.
		zeh rA, rB
		
		// rA = Sign extend of low 16 bits in rB
		// This instruction affects the N and Z flags.
		seh rA, rB
		
		
		
		// Copy (rA = rB)
		// This instruction does not affect flags.
		cpy rA, rB
		
		// Copy Negated (rA = -rB)
		// This instruction affects the N and Z flags.
		cpn rA, rB
		
		// Copy Complemented (rA = ~rB)
		// This instruction affects the N and Z flags.
		cpc rA, rB
		
		// Swap (temp = rA; rA = rB; rB = temp)
		// Not sure how useful this is, but you can swap with the stack
		// pointer or with the link register
		// This instruction does not affect flags.
		swp rA, rB


Group 2 Instructions
0010 oooo aaaa bbbb iiii iiii iiii iiii
	
	o:  opcode
	a:  rA
	b:  rB
	i:  16-bit immediate value
	
	Instructions:
		// Load 32-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldrxi rA, rB, imm
		
		// Load unsigned 16-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldhxi rA, rB, imm
		
		// Load signed 16-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldshxi rA, rB, imm
		
		// Load unsigned 8-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldbxi rA, rB, imm
		
		
		
		// Load signed 8-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldsbxi rA, rB, imm
		
		// Store 32-bit value in rA to address in (rB + (sign-extended imm))
		// This instruction does not affect flags.
		strxi rA, rB, imm
		
		// Store low 16 bits of rA to address in (rB + (sign-extended imm))
		// This instruction does not affect flags.
		sthxi rA, rB, imm
		
		// Store low 8 bits of rA to address in (rB + (sign-extended imm))
		// This instruction does not affect flags.
		stbxi rA, rB, imm
		
		
		
		// rA low 16 bits = imm
		// This instruction does not affect flags.
		// Note that rB is ignored.
		cpylo rA, imm
		
		// rA high 16 bits = imm
		// This instruction does not affect flags.
		// Note that rB is ignored.
		cpyhi rA, imm
		
		// rA = rB + (sign-extended imm)
		// This instruction affects N, V, Z, and C flags.
		addi rA, rB, imm
		
		// Logical shift left, by (zero-extended imm) bits
		// This instruction affects the N and Z flags.
		lsli rA, rB, imm
		
		
		
		// Logical shift right, by (zero-extended imm) bits
		// This instruction affects the N and Z flags.
		lsri rA, rB, imm
		
		// Arithmetic shift right, by (zero-extended imm) bits
		// This instruction affects the N and Z flags.
		asri rA, rB, imm
		
		// Rotate rA left (NOT through carry) by (zero-extended imm)
		// bits, ignoring rB
		roli rA, imm
		
		// Rotate rA right (NOT through carry) by (zero-extended imm)
		// bits, ignoring rB
		rori rA, imm
		
		
		
		// Pseudo instruction:
		//// rA = rB - (sign-extended imm)
		//// This instruction affects N, V, Z, and C flags.
		//subi rA, rB, imm
		
