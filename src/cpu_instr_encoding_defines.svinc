`ifndef cpu_instr_encoding_defines_svinc
`define cpu_instr_encoding_defines_svinc

`include "src/misc_defines.svinc"


`define CPU_INSTR_MAX_WIDTH 48
`define CPU_INSTR_MAX_MSB_POS `WIDTH_TO_MSB_POS(`CPU_INSTR_MAX_WIDTH)

`define CPU_INSTR_ENC_GROUP_WIDTH 2
`define CPU_INSTR_ENC_GROUP_MSB_POS \
	`WIDTH_TO_MSB_POS(`CPU_INSTR_ENC_GROUP_WIDTH)

`define CPU_INSTR_ENC_OPER_WIDTH 5
`define CPU_INSTR_ENC_OPER_MSB_POS \
	`WIDTH_TO_MSB_POS(`CPU_INSTR_ENC_OPER_WIDTH)

`define CPU_INSTR_ENC_REG_INDEX_WIDTH 4
`define CPU_INSTR_ENC_REG_INDEX_MSB_POS \
	`WIDTH_TO_MSB_POS(`CPU_INSTR_ENC_REG_INDEX_WIDTH)

`define CPU_INSTR_ENC_UIMM16_WIDTH 16
`define CPU_INSTR_ENC_UIMM16_MSB_POS \
	`WIDTH_TO_MSB_POS(`CPU_INSTR_ENC_UIMM16_WIDTH)


`define CPU_INSTR_ENC_SIMM16_WIDTH 16
`define CPU_INSTR_ENC_SIMM16_MSB_POS \
	`WIDTH_TO_MSB_POS(`CPU_INSTR_ENC_SIMM16_WIDTH)


`define CPU_INSTR_ENC_SIMM12_WIDTH 12
`define CPU_INSTR_ENC_SIMM12_MSB_POS \
	`WIDTH_TO_MSB_POS(`CPU_INSTR_ENC_SIMM12_WIDTH)

`define CPU_INSTR_ENC_IMM32_WIDTH 32
`define CPU_INSTR_ENC_IMM32_MSB_POS \
	`WIDTH_TO_MSB_POS(`CPU_INSTR_ENC_IMM32_WIDTH)



// 
`define CPU_INSTR_ENC_MAX_IMM_VALUE_WIDTH 32
`define CPU_INSTR_ENC_MAX_IMM_VALUE_MSB_POS \
	`WIDTH_TO_MSB_POS(`CPU_INSTR_ENC_MAX_IMM_VALUE_WIDTH)




// Some Abbreviations:
//
// IE:  Instruction Encoding
//
// 
// G1:  Group 1
// G2:  Group 2
// G3:  Group 3
//
// 
// HW0:  Half Word 0:  
//		bits 15-0 of 16-bit instructions
//		bits 31-16 of 32-bit instructions
//		bits 47-32 of 48-bit instructions
// 
// HW1:  Half Word 1:  
//		bits 15-0 of 32-bit instructions
//		bits 31-16 of 48-bit instructions
// 
// HW2:  Half Word 2:
//		bits 15-0 of 48-bit instructions
//
//
// NONBLK:  Non Block Move instructions
// BLK:  Block Move instructions


// Encoding group
`define CPU_IE_HW0_ENC_GROUP__HIGH_BIT 15
`define CPU_IE_HW0_ENC_GROUP__LOW_BIT 14



// If flags are possible to change (some instructions don't affect flags
// anyway though)
//
// I guess "pop flags" discards the results despite affecting the stack
// pointer?  I might want to change that....
`define CPU_IE_HW0_MIGHT_AFFECT_FLAGS__BIT 13



// What type of operation (add, sub, ldr, mul, subi, etc.)
`define CPU_IE_HW0_OPER__HIGH_BIT 12
`define CPU_IE_HW0_OPER__LOW_BIT 8


// rA
`define CPU_IE_HW0_REG_A_INDEX__HIGH_BIT 7
`define CPU_IE_HW0_REG_A_INDEX__LOW_BIT 4


// rB
`define CPU_IE_HW0_REG_B_INDEX__HIGH_BIT 3
`define CPU_IE_HW0_REG_B_INDEX__LOW_BIT 0




// Peculiarities to Instruction Groups other than 0:


// [Encoding of] Group 1 Instructions
// 01fo oooo aaaa bbbb  iiii iiii iiii iiii

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// i:  16-bit immediate value


// The 16-bit immediate value of a group 1 instruction:  
`define CPU_IE_G1_HW1_IMM_VALUE__HIGH_BIT 15
`define CPU_IE_G1_HW1_IMM_VALUE__LOW_BIT 0
// Well that's simple.






// [Encoding of] Group 2 Instructions
// Non Block Moves Version:  
	// 10fo oooo aaaa bbbb  cccc iiii iiii iiii

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// i:  12-bit immediate value

// Block Moves Version (stmdb, ldmia, stmia, push, pop):  
	// 10fo oooo aaaa bbbb  cccc dddd xxxx 00ii

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// d: rD
	// x: rX
	// i:  2-bit immediate value


// rC
// Note that both block moves version and non block moves version group 2
// instructions have rC in their encoding
`define CPU_IE_G2_HW1_REG_C_INDEX__HIGH_BIT 15
`define CPU_IE_G2_HW1_REG_C_INDEX__LOW_BIT 12


// The 12-bit immediate value of a non-block move group 2 instruction:
`define CPU_IE_G2_NONBLK_HW1_IMM_VALUE__HIGH_BIT 11
`define CPU_IE_G2_NONBLK_HW1_IMM_VALUE__LOW_BIT 0



// Block move:  rD
`define CPU_IE_G2_BLK_HW1_REG_D_INDEX__HIGH_BIT 11
`define CPU_IE_G2_BLK_HW1_REG_D_INDEX__LOW_BIT 8


// Block move:  rX
`define CPU_IE_G2_BLK_HW1_REG_X_INDEX__HIGH_BIT 7
`define CPU_IE_G2_BLK_HW1_REG_X_INDEX__LOW_BIT 4

// Block move:  00
`define CPU_IE_G2_BLK_HW1_BLANK__HIGH_BIT 3
`define CPU_IE_G2_BLK_HW1_BLANK__LOW_BIT 2

// Block move:  00 for one address reg, 01 for two address regs, 10 for
// three address regs, 11 for four address regs
`define CPU_IE_G2_BLK_HW1_NUM_REGS__HIGH_BIT 1
`define CPU_IE_G2_BLK_HW1_NUM_REGS__LOW_BIT 0



// Group 3 Instructions
// Two Registers Version:  
	// 11fo oooo aaaa bbbb  iiii iiii iiii iiii  iiii iiii iiii iiii

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// i:  32-bit immediate value

// Block Moves Version (stmdb, ldmia, stmia, push, pop):  
	// 11fo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh xxxx 00ii

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// d: rD
	// e: rE
	// f: rF
	// g: rG
	// h: rH
	// x: rX
	// i:  2-bit immediate value

// 32-bit by 32-bit -> 64-bit Multiply Version:
	// 11fo oooo aaaa bbbb  cccc dddd 0000 0000  0000 0000 0000 0000

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// d: rD


// 64-bit by 64-bit -> 64-bit DivMod Version:
	// 11fo oooo aaaa bbbb  cccc dddd eeee ffff  gggg hhhh 0000 0000

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// d: rD
	// e: rE
	// f: rF
	// g: rG
	// h: rH

// 32-bit by 32-bit -> 32-bit DivMod Version:
	// 11fo oooo aaaa bbbb  cccc dddd 0000 0000  0000 0000 0000 0000

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// d: rD

// 64-bit bitshifted by 64-bit -> 64-bit Version:
	// 11fo oooo aaaa bbbb  cccc dddd eeee ffff  0000 0000 0000 0000

	// f:  1 if can affect flags (and instruction type supports it), 0 if
	// flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// d: rD
	// e: rE
	// f: rF


// The 32-bit immediate of 48-bit instructions that involve only two
// registers
`define CPU_IE_G3_TWO_REGS_HW1_IMM_VALUE__HIGH_BIT 15
`define CPU_IE_G3_TWO_REGS_HW1_IMM_VALUE__LOW_BIT 0
`define CPU_IE_G3_TWO_REGS_HW2_IMM_VALUE__HIGH_BIT 15
`define CPU_IE_G3_TWO_REGS_HW2_IMM_VALUE__LOW_BIT 0



// More than two registers:  rC index
`define CPU_IE_G3_MULTI_REGS_HW1_REG_C_INDEX__HIGH_BIT 15
`define CPU_IE_G3_MULTI_REGS_HW1_REG_C_INDEX__LOW_BIT 12

// More than two registers:  rD index
`define CPU_IE_G3_MULTI_REGS_HW1_REG_D_INDEX__HIGH_BIT 11
`define CPU_IE_G3_MULTI_REGS_HW1_REG_D_INDEX__LOW_BIT 8

// More than two registers:  rE index
`define CPU_IE_G3_MULTI_REGS_HW1_REG_E_INDEX__HIGH_BIT 7
`define CPU_IE_G3_MULTI_REGS_HW1_REG_E_INDEX__LOW_BIT 4

// More than two registers:  rF index
`define CPU_IE_G3_MULTI_REGS_HW1_REG_F_INDEX__HIGH_BIT 3
`define CPU_IE_G3_MULTI_REGS_HW1_REG_F_INDEX__LOW_BIT 0



// More than two registers:  rG index
`define CPU_IE_G3_MULTI_REGS_HW2_REG_G_INDEX__HIGH_BIT 15
`define CPU_IE_G3_MULTI_REGS_HW2_REG_G_INDEX__LOW_BIT 12

// More than two registers:  rH index
`define CPU_IE_G3_MULTI_REGS_HW2_REG_H_INDEX__HIGH_BIT 11
`define CPU_IE_G3_MULTI_REGS_HW2_REG_H_INDEX__LOW_BIT 8


// Block move:  rX index
`define CPU_IE_G3_BLK_HW2_REG_X_INDEX__HIGH_BIT 7
`define CPU_IE_G3_BLK_HW2_REG_X_INDEX__LOW_BIT 4


// Block move:  00
`define CPU_IE_G3_BLK_HW2_BLANK__HIGH_BIT 3
`define CPU_IE_G3_BLK_HW2_BLANK__LOW_BIT 2

// Block move:  00 for five address regs, 01 for six address regs, 10 for
// seven address regs, 11 for eight address regs
`define CPU_IE_G3_BLK_HW2_NUM_REGS__HIGH_BIT 1
`define CPU_IE_G3_BLK_HW2_NUM_REGS__LOW_BIT 0


`endif		// cpu_instr_encoding_defines_svinc
