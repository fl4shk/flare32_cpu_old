Three instruction encoding sizes:  16-bit, 32-bit, and 48-bit

The instruction group is a 4-bit field, the 4 most significant bits of the
first 16-bits.

Group 0 Instructions, for example, use 0000 as their group identifier.

Group 0 Instructions
000o oooo aaaa bbbb
	
	o:  opcode
	a:  rA (destination register usually)
	b:  rB
	
	Instructions:
		// This instruction affects N, V, Z, and C flags.
		add rA, rB
		
		// Add with carry
		// This instruction affects N, V, Z, and C flags.
		adc rA, rB
		
		// This instruction affects N, V, Z, and C flags.
		sub rA, rB
		
		// Subtract with borrow (6502 style)
		// This instruction affects N, V, Z, and C flags.
		sbc rA, rB
		
		
		
		// This instruction ONLY affects flags.
		cmp rA, rB
		
		// Logical shift left
		// This instruction affects the N and Z flags.
		lsl rA, rB
		
		// Logical shift right
		// This instruction affects the N and Z flags.
		lsr rA, rB
		
		// Arithmetic shift right
		// This instruction affects the N and Z flags.
		asr rA, rB
		
		
		
		// This instruction affects the N and Z flags.
		and rA, rB
		
		// This instruction affects the N and Z flags.
		or rA, rB
		
		// This instruction affects the N and Z flags.
		xor rA, rB
		
		// rA *= rB
		// This instruction affects the N and Z flags.
		mul rA, rB
		
		
		
		// Rotate rA left (NOT through carry) by rB bits.
		// This instruction affects the N and Z flags.
		rol rA, rB
		
		// Rotate rA right (NOT through carry) by rB bits.
		// This instruction affects the N and Z flags.
		ror rA, rB
		
		// Rotate rA left (THROUGH carry) by 1 bit, ignoring rB.
		// This instruction affects N, Z, and C flags.
		// Note that rB is ignored.
		rlc rA
		
		// Rotate rA right (THROUGH carry) by 1 bit, ignoring rB.
		// This instruction affects N, Z, and C flags.
		// Note that rB is ignored.
		rrc rA
		
		
		
		
		
		// Load 32-bit value from address in rB into rA
		// This instruction does not affect flags.
		ldr rA, rB
		
		// Load unsigned 16-bit value from address in rB into rA
		// This zero extends the value.
		// This instruction does not affect flags.
		ldh rA, rB
		
		// Load signed 16-bit value from address in rB into rA
		// This sign extends the value.
		// This instruction does not affect flags.
		ldsh rA, rB
		
		// Load unsigned 8-bit value from address in rB into rA
		// This zero extends the value.
		// This instruction does not affect flags.
		ldb rA, rB
		
		
		
		// Load signed 8-bit value from address in rB into rA
		// This sign extends the value.
		// This instruction does not affect flags.
		ldsb rA, rB
		
		// Store 32-bit value in rA to address in rB
		// This instruction does not affect flags.
		str rA, rB
		
		// Store low 16 bits of rA to address in rB
		// This instruction does not affect flags.
		sth rA, rB
		
		// Store low 8 bits of rA to address in rB
		// This instruction does not affect flags.
		stb rA, rB
		
		
		
		// rA = Zero extend of low 8 bits in rB
		// This instruction affects the N and Z flags.
		zeb rA, rB
		
		// rA = Sign extend of low 8 bits in rB
		// This instruction affects the N and Z flags.
		seb rA, rB
		
		// rA = Zero extend of low 16 bits in rB
		// This instruction affects the N and Z flags.
		zeh rA, rB
		
		// rA = Sign extend of low 16 bits in rB
		// This instruction affects the N and Z flags.
		seh rA, rB
		
		
		
		// Copy (rA = rB)
		// This instruction does not affect flags.
		cpy rA, rB
		
		// Copy Negated (rA = -rB)
		// This instruction does not affect flags.
		cpn rA, rB
		
		// Copy Complemented (rA = ~rB)
		// This instruction does not affect flags.
		cpc rA, rB
		
		// Swap (temp = rA; rA = rB; rB = temp)
		// Not sure how useful this is, but you can swap with the stack
		// pointer or with the link register
		// This instruction does not affect flags.
		swp rA, rB

Group 1 Instructions
001o oooo aaaa bbbb
	
	o:  opcode
	a:  rA
	b:  rB
	
	Instructions:
		// rA = rB + 1
		// This instruction affects N, V, Z, and C flags.
		inc rA, rB
		
		// rA = rB - 1
		// This instruction affects N, V, Z, and C flags.
		dec rA, rB
		
		// rA:rB = (64-bit zero extend of rA) * (64-bit zero extend of rB)
		// Note that rA will contain the high 32 bits of the unsigned 64-bit product
		// Note that rB will contain the low 32 bits of the unsigned 64-bit product
		// This instruction does not affect flags.
		umull rA, rB
		
		// rA:rB = (64-bit sign extend of rA) * (64-bit sign extend of rB)
		// Note that rA will contain the high 32 bits of the signed 64-bit product
		// Note that rB will contain the low 32 bits of the signed 64-bit product
		// This instruction does not affect flags.
		smull rA, rB
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.


Group 2 Instructions
010o oooo aaaa bbbb iiii iiii iiii iiii
	
	o:  opcode
	a:  rA
	b:  rB
	i:  16-bit immediate value
	
	Instructions:
		// Load 32-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldrxi rA, rB, imm
		
		// Load unsigned 16-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldhxi rA, rB, imm
		
		// Load signed 16-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldshxi rA, rB, imm
		
		// Load unsigned 8-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldbxi rA, rB, imm
		
		
		
		// Load signed 8-bit value from address in (rB + (sign-extended imm)) into rA
		// This instruction does not affect flags.
		ldsbxi rA, rB, imm
		
		// Store 32-bit value in rA to address in (rB + (sign-extended imm))
		// This instruction does not affect flags.
		strxi rA, rB, imm
		
		// Store low 16 bits of rA to address in (rB + (sign-extended imm))
		// This instruction does not affect flags.
		sthxi rA, rB, imm
		
		// Store low 8 bits of rA to address in (rB + (sign-extended imm))
		// This instruction does not affect flags.
		stbxi rA, rB, imm
		
		
		
		// rA low 16 bits = imm
		// This instruction does not affect flags.
		// Note that rB is ignored.
		cpyloi rA, imm
		
		// rA high 16 bits = imm
		// This instruction does not affect flags.
		// Note that rB is ignored.
		cpyhii rA, imm
		
		// rA = rB + (sign-extended imm)
		// This instruction affects N, V, Z, and C flags.
		addsi rA, rB, imm
		
		// Logical shift left, by (zero-extended imm) bits
		// This instruction affects the N and Z flags.
		lsli rA, rB, imm
		
		
		
		// Logical shift right, by (zero-extended imm) bits
		// This instruction affects the N and Z flags.
		lsri rA, rB, imm
		
		// Arithmetic shift right, by (zero-extended imm) bits
		// This instruction affects the N and Z flags.
		asri rA, rB, imm
		
		// Rotate rA left (NOT through carry) by (zero-extended imm)
		// bits, ignoring rB
		roli rA, imm
		
		// Rotate rA right (NOT through carry) by (zero-extended imm)
		// bits, ignoring rB
		rori rA, imm
		
		
		
		
		// aaaa
		GGGGG imm
		
		// Branch always, to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bra imm
		
		// Branch when Z == 0, to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bne imm
		
		// Branch when Z == 1, to (pc when instruction starts) + (sign extended 16-bit immediate value)
		beq imm
		
		
		
		// Branch when C == 0 [unsigned less than], to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bcc imm
		
		// Branch when C == 1 [unsigned greater than or equal], to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bcs imm
		
		// Branch when ( C == 0 or Z == 1 ) [unsigned less than or equal], to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bls imm
		
		// Branch when ( C == 1 and Z == 0 ) [unsigned greater than], to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bhi imm
		
		
		
		// Branch when N == 0, to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bpl imm
		
		// Branch when N == 1, to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bmi imm
		
		// Branch when V == 0, to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bvc imm
		
		// Branch when V == 1, to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bvs imm
		
		
		
		// Branch when N == V [signed greater than or equal], to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bge imm
		
		// Branch when N != V [signed less than], to (pc when instruction starts) + (sign extended 16-bit immediate value)
		blt imm
		
		// Branch when ( N == V and Z == 0 ) [signed greater than], to (pc when instruction starts) + (sign extended 16-bit immediate value)
		bgt imm
		
		// Branch when ( N != V or Z == 1 ) [signed less than or equal], to (pc when instruction starts) + (sign extended 16-bit immediate value)
		ble imm
		
		
		
		// Pseudo instruction:
		//// rA = rB - (sign-extended imm)
		//// This instruction affects N, V, Z, and C flags.
		//subsi rA, rB, imm
		
