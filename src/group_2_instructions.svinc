`ifndef group_2_instructions_svinc
`define group_2_instructions_svinc

// Group 2 Instructions
// Non Block Moves Version:  
	// 10fo oooo aaaa bbbb  cccc iiii iiii iiii

	// f:  1 if can affect Flags (and instruction type supports it), 0 if
	// Flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// i:  12-bit immediate value

// Block Moves Version (stmdb, ldmia, stmia, push, pop):  
	// 10fo oooo aaaa bbbb  cccc dddd xxxx 00ii

	// f:  1 if can affect Flags (and instruction type supports it), 0 if
	// Flags unchanged.

	// o:  opcode
	// a: rA
	// b: rB
	// c: rC
	// d: rD
	// x: rX
	// i:  2-bit immediate value


`define LIST_OF_INSTR_G2_LDST_RA_RB_RC_SIMM12__COLLECTION_0 \
/* Load 32-bit value from address (rB + rC + (sign-extended imm)) into */ \
/* rA. */ \
`INSTR_STUFF(2, LdStRaRbRcSImm12, Ldr, "ldr") \
\
/* Load zero-extended 16-bit value from address (rB + rC + */ \
/* (sign-extended imm)) into rA. */ \
/* This zero-extends the value. */ \
`INSTR_STUFF(2, LdStRaRbRcSImm12, Ldh, "ldh") \
\
/* Load sign-extended 16-bit value from address (rB + rC + */ \
/* (sign-extended imm)) into rA. */ \
/* This sign-extends the value. */ \
`INSTR_STUFF(2, LdStRaRbRcSImm12, Ldsh, "ldsh") \
\
/* Load zero-extended 8-bit value from address (rB + rC + */ \
/* (sign-extended imm)) into rA. */ \
/* This zero-extends the value. */ \
`INSTR_STUFF(2, LdStRaRbRcSImm12, Ldb, "ldb") \
\
\
\
/* Load sign-extended 8-bit value from address (rB + rC + */ \
/* (sign-extended imm)) into rA. */ \
/* This sign-extends the value. */ \
`INSTR_STUFF(2, LdStRaRbRcSImm12, Ldsb, "ldsb") \
\
/* Store 32-bit value in rA to address (rB + rC + */ \
/* (sign-extended imm)). */ \
`INSTR_STUFF(2, LdStRaRbRcSImm12, Str, "str") \
\
/* Store low 16 bits of rA to address (rB + rC + (sign-extended imm)). */ \
`INSTR_STUFF(2, LdStRaRbRcSImm12, Sth, "sth") \
\
/* Store low 8 bits of rA to address (rB + rC + (sign-extended imm)). */ \
`INSTR_STUFF(2, LdStRaRbRcSImm12, Stb, "stb")


`define LIST_OF_INSTR_G2_RA_RB_RC__COLLECTION_0 \
/* rA = rB + rC */ \
/* This instruction can affect N, V, Z, and C Flags. */ \
`INSTR_STUFF(2, RaRbRc, Add, "add") \
\
/* rA = rB + rC + carry_flag */ \
/* Add with carry */ \
/* This instruction can affect N, V, Z, and C Flags. */ \
`INSTR_STUFF(2, RaRbRc, Adc, "adc") \
\
/* rA = rB - rC */ \
/* This instruction can affect N, V, Z, and C Flags. */ \
`INSTR_STUFF(2, RaRbRc, Sub, "sub") \
\
/* rA = rB + (~rC) + carry_flag */ \
/* Subtract with borrow (6502 style) */ \
/* This instruction can affect N, V, Z, and C Flags. */ \
`INSTR_STUFF(2, RaRbRc, Sbc, "sbc") \
\
\
\
/* rA = rC - rB */ \
/* This instruction can affect N, V, Z, and C Flags. */ \
`INSTR_STUFF(2, RaRbRc, Rsb, "rsb") \
\
/* rA = rB * rC */ \
`INSTR_STUFF(2, RaRbRc, Mul, "mul") \
\
/* rA = rB & rC */ \
/* This instruction can affect the N and Z Flags. */ \
`INSTR_STUFF(2, RaRbRc, And, "and") \
\
/* rA = rB | rC */ \
/* This instruction can affect the N and Z Flags. */ \
`INSTR_STUFF(2, RaRbRc, Or, "or") \
\
\
\
/* rA = rB ^ rC */ \
/* This instruction can affect the N and Z Flags. */ \
`INSTR_STUFF(2, RaRbRc, Xor, "xor") \
\
/* Logical shift left */ \
/* rA = rB << rC */ \
`INSTR_STUFF(2, RaRbRc, Lsl, "lsl") \
\
/* Logical shift right */ \
`INSTR_STUFF(2, RaRbRc, Lsr, "lsr") \
\
/* Arithmetic shift right */ \
`INSTR_STUFF(2, RaRbRc, Asr, "asr") \
\
\
\
/* Rotate rC left by rC bits, then store result in rA. */ \
`INSTR_STUFF(2, RaRbRc, Rol, "rol") \
\
/* Rotate rC right by rC bits, then store result in rA. */ \
`INSTR_STUFF(2, RaRbRc, Ror, "ror") \
\
/* Fused multiply-add */ \
/* rA = rA + (rB * rC) */ \
`INSTR_STUFF(2, RaRbRc, Fma, "fma") \
\
/* Copy rC to rA and to rB */ \
/* If rA is the same register as rB, then the  */ \
/* register will only be written once. */ \
`INSTR_STUFF(2, RaRbRc, Cpyp, "cpyp")


`define LIST_OF_INSTR_G2_LDST_BLOCK_1_TO_4__COLLECTION_0 \
/* STore Multiple, Decrement Before */ \
/* Note that this instruction takes multiple forms */ \
`INSTR_STUFF(2, LdStBlock1To4, Stmdb, "stmdb") \
\
\
/* LoaD Multiple, Increment After */ \
/* Note that this instruction takes multiple forms */ \
`INSTR_STUFF(2, LdStBlock1To4, Ldmia, "ldmia") \
\
\
/* STore Multiple, Increment After */ \
/* Note that this instruction takes multiple forms */ \
`INSTR_STUFF(2, LdStBlock1To4, Stmia, "stmia")



`define LIST_OF_INSTR_G2_NO_ARGS__COLLECTION_0 \
/* ENable Interrupts */ \
`INSTR_STUFF(2, NoArgs, Eni, "eni") \
\
\
\
/* DIsable Interrupts */ \
`INSTR_STUFF(2, NoArgs, Dii, "dii") \
\
/* Set the PC to interrupt RETurn address and enable Interrupts */ \
`INSTR_STUFF(2, NoArgs, Reti, "reti")


`define LIST_OF_INSTR_G2_IRA__COLLECTION_0 \
/* Set the PC to the Interrupt Return Address, but DON'T enable */ \
/* interrupts */ \
`INSTR_STUFF(2, Ira, Jump, "jump")

/* Reserved for future expansion. */

`define LIST_OF_GROUP_2_INSTRUCTIONS \
`LIST_OF_INSTR_G2_LDST_RA_RB_RC_SIMM12__COLLECTION_0 \
`LIST_OF_INSTR_G2_RA_RB_RC__COLLECTION_0 \
`LIST_OF_INSTR_G2_LDST_BLOCK_1_TO_4__COLLECTION_0 \
`LIST_OF_INSTR_G2_NO_ARGS__COLLECTION_0 \
`LIST_OF_INSTR_G2_IRA__COLLECTION_0

`endif		// group_2_instructions_svinc
