#define concat #1#2
#if 0

#endif
#define FLAGS_NONE // This instruction does not affect flags.
#define FLAGS_N_AND_Z // This instruction affects the N and Z flags.
#define FLAGS_ONLY(f) // This instruction only affects the f flag.
#define FLAGS_N_AND_Z_AND_C // This instruction affects N, Z, and C flags.
#define FLAGS_ALL // This instruction affects N, V, Z, and C flags.
#if 0


#endif
#define DESCRIBE_OP o:  opcode
#define DESCRIBE_RA a:  rA
#define DESCRIBE_RB b:  rB
#define DESCRIBE_RC c:  rc
#define DESCRIBE_IMM(x) i:  x-bit immediate value
#define DESCRIBE_IMM_UNSIGNED(x) DESCRIBE_IMM(zero-extended x)
#define DESCRIBE_IMM_SIGNED(x) DESCRIBE_IMM(sign-extended x)
#define DESCRIBE_INSTRUCTIONS Instructions:
#define DESCRIBE_PSEUDO_INSTRUCTION // Pseudo instruction:
#if 0


#endif
#define _DESCRIBE_LOAD_PART_1(x) // Load x-bit value from address
#define _DESCRIBE_LOAD_US_PART_1( us, x ) // Load us x-bit value from address
#define _DESCRIBE_LOAD_PART_2(arg_address) arg_address into ARG_REG(A).
#define DESCRIBE_LOAD_32(arg_address) _DESCRIBE_LOAD_PART_1(32) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_16_UNSIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(zero-extended,16) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_16_SIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(sign-extended,16) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_8_UNSIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(zero-extended,8) _DESCRIBE_LOAD_PART_2(arg_address)
#define DESCRIBE_LOAD_8_SIGNED(arg_address) _DESCRIBE_LOAD_US_PART_1(sign-extended,8) _DESCRIBE_LOAD_PART_2(arg_address)
#if 0


#endif
#define _DESCRIBE_STORE( x, arg_address ) // Store x ARG_REG(A) to address arg_address.
#define DESCRIBE_STORE_32(arg_address) _DESCRIBE_STORE(32-bit value in,arg_address)
#define DESCRIBE_STORE_16(arg_address) _DESCRIBE_STORE(low 16 bits of,arg_address)
#define DESCRIBE_STORE_8(arg_address) _DESCRIBE_STORE(low 8 bits of,arg_address)
#if 0


#endif
#define _DESCRIBE_ROTATE( lr, amount, src, dst ) // Rotate src lr by amount, then store result in dst
#define DESCRIBE_ROTATE_NOT_THROUGH_CARRY( lr, amount ) _DESCRIBE_ROTATE(lr (NOT through carry),amount bits,ARG_REG(A),ARG_REG(A)).
#define DESCRIBE_ROTATE_THROUGH_CARRY(lr) _DESCRIBE_ROTATE(lr (THROUGH carry),1 bit,ARG_REG(B),ARG_REG(A)).
#define DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY( lr, amount ) _DESCRIBE_ROTATE(lr,amount bits,ARG_REG(B),ARG_REG(A)).
#if 0


#endif
#define DESCRIBE_ZERO_EXTEND // This zero-extends the value.
#define DESCRIBE_SIGN_EXTEND // This sign-extends the value.
#if 0


#endif
#define DESCRIBE_JUMP_DESTINATION_ADDRESS(addr) // Set pc to destination address in addr.
#define DESCRIBE_CALL_DESTINATION_ADDRESS(addr) // Subroutine call using addr as destination address. 
#define DESCRIBE_CALL_RETURN_ADDRESS // The return address is stored in the link register (lr).
#define DESCRIBE_BRANCH_TARGET to ( (pc when instruction starts) \
		// + (sign-extended 16-bit immediate value) )
#if 0


#endif
#define DESCRIBE_RB_OP_RC_PLUS_SE_IMM_LINE_1(op) // op two registers,
#define DESCRIBE_RB_OP_RC_PLUS_SE_IMM_LINE_1_TYPE_2(op) // op ARG_REG(B) by ARG_REG(C),
#define DESCRIBE_RB_OP_RC_PLUS_SE_IMM_LINE_2 // and then add sign extended immediate \(can set immediate to zero
#define DESCRIBE_RB_OP_RC_PLUS_SE_IMM_LINE_3 // if needed\)
#define DESCRIBE_RB_OP_RC_PLUS_SE_IMM_LINE_4(op,B,C) // ARG_REG(A) = (ARG_REG(B) op ARG_REG(C)) + IMM_SIGN_EXTENDED
#if 0


#endif
#define GROUP_HEADER(x) Group x Instructions
#if 0


#endif
#define ARG_REG(x) concat(r,x)
#define ARG_TEMP temp
#define ARG_IMM imm
#define IMM_ZERO_EXTENDED (zero-extended ARG_IMM)
#define IMM_SIGN_EXTENDED (sign-extended ARG_IMM)
#define ARG_ABS absolute_addr
#define ARG_FOR_LDST_NON_INDEXED ARG_REG(B)
#define ARG_FOR_LDST_IMM_INDEXED(immediate) (ARG_FOR_LDST_NON_INDEXED + immediate)
#define ARG_FOR_LDST_GENERIC_INDEXED(immediate) (ARG_FOR_LDST_NON_INDEXED + ARG_REG(C) + immediate)
#define ARG_FOR_LDST_ABS ARG_ABS
#define ARG_FOR_LDST_ABS_INDEXED (ARG_FOR_LDST_ABS + ARG_REG(B))
#define ARG_CARRY carry_flag
#define IGNORE_REG(x) // Note that ARG_REG(x) is ignored.
#if 0


#endif
#define INSTR_NO_ARGS(instr) instr
#define INSTR_ONE_ARG( instr, arg ) INSTR_NO_ARGS(instr) arg
#define INSTR_IMM( instr, immediate ) INSTR_ONE_ARG(instr,immediate)
#define INSTR_WITH_REG( instr, regno ) INSTR_ONE_ARG(instr,ARG_REG(regno))
#define INSTR_RA(instr) INSTR_WITH_REG(instr,A)
#define INSTR_RA_IMM( instr, immediate ) INSTR_RA(instr), immediate
#define INSTR_RA_RB(instr) INSTR_RA(instr), ARG_REG(B)
#define INSTR_RA_RB_IMM( instr, immediate ) INSTR_RA_RB(instr), immediate
#define INSTR_RA_RB_RC(instr) INSTR_RA_RB(instr), ARG_REG(C)
#define INSTR_RA_RB_RC_IMM( instr, immediate ) INSTR_RA_RB_RC(instr), immediate
#define PSEUDO_INSTR_RB(instr) INSTR_WITH_REG(instr,B)
#define PSEUDO_INSTR_RB_IMM( instr, immediate ) PSEUDO_INSTR_RB(instr), immediate
#define PSEUDO_INSTR_RB_RC(instr) PSEUDO_INSTR_RB(instr), ARG_REG(C)
#define PSEUDO_INSTR_RB_RC_IMM( instr, immediate ) PSEUDO_INSTR_RB_RC(instr), immediate
#define PSEUDO_INSTR_RA_RC(instr) INSTR_RA(instr), ARG_REG(C)
#define DESCRIBE_PSEUDO_INSTR_ENCODING( real_instr, arg ) //// Encoded like this:  real_instr arg
#define DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING( real_instr, arg ) DESCRIBE_PSEUDO_INSTR_ENCODING(real_instr,ARG_REG(0)\, arg)
#define DESCRIBE_PSEUDO_INSTR_T_ENCODING( real_instr, first_arg, last_arg ) DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(real_instr,first_arg\, last_arg)
#define RESERVED // Reserved for future expansion.
#if 0


#endif
#define GEN_LDST_NO_SUFFIX( arg_address ) DESCRIBE_LOAD_32(arg_address) \
		__TEMP_LDST_INSTR_TYPE(ldr) \
		\
		DESCRIBE_LOAD_16_UNSIGNED(arg_address) \
		DESCRIBE_ZERO_EXTEND \
		__TEMP_LDST_INSTR_TYPE(ldh) \
		\
		DESCRIBE_LOAD_16_SIGNED(arg_address) \
		DESCRIBE_SIGN_EXTEND \
		__TEMP_LDST_INSTR_TYPE(ldsh) \
		\
		DESCRIBE_LOAD_8_UNSIGNED(arg_address) \
		DESCRIBE_ZERO_EXTEND \
		__TEMP_LDST_INSTR_TYPE(ldb) \
		\
		\
		\
		DESCRIBE_LOAD_8_SIGNED(arg_address) \
		DESCRIBE_SIGN_EXTEND \
		__TEMP_LDST_INSTR_TYPE(ldsb) \
		\
		DESCRIBE_STORE_32(arg_address) \
		__TEMP_LDST_INSTR_TYPE(str) \
		\
		DESCRIBE_STORE_16(arg_address) \
		__TEMP_LDST_INSTR_TYPE(sth) \
		\
		DESCRIBE_STORE_8(arg_address) \
		__TEMP_LDST_INSTR_TYPE(stb)
#define GEN_LDST_WITH_SUFFIX( arg_address, suffix ) DESCRIBE_LOAD_32(arg_address) \
		__TEMP_LDST_INSTR_TYPE(concat(ldr,suffix)) \
		\
		DESCRIBE_LOAD_16_UNSIGNED(arg_address) \
		DESCRIBE_ZERO_EXTEND \
		__TEMP_LDST_INSTR_TYPE(concat(ldh,suffix)) \
		\
		DESCRIBE_LOAD_16_SIGNED(arg_address) \
		DESCRIBE_SIGN_EXTEND \
		__TEMP_LDST_INSTR_TYPE(concat(ldsh,suffix)) \
		\
		DESCRIBE_LOAD_8_UNSIGNED(arg_address) \
		DESCRIBE_ZERO_EXTEND \
		__TEMP_LDST_INSTR_TYPE(concat(ldb,suffix)) \
		\
		\
		\
		DESCRIBE_LOAD_8_SIGNED(arg_address) \
		DESCRIBE_SIGN_EXTEND \
		__TEMP_LDST_INSTR_TYPE(concat(ldsb,suffix)) \
		\
		DESCRIBE_STORE_32(arg_address) \
		__TEMP_LDST_INSTR_TYPE(concat(str,suffix)) \
		\
		DESCRIBE_STORE_16(arg_address) \
		__TEMP_LDST_INSTR_TYPE(concat(sth,suffix)) \
		\
		DESCRIBE_STORE_8(arg_address) \
		__TEMP_LDST_INSTR_TYPE(concat(stb,suffix))
#if 0

You won't see this sentence in the final .txt file.
It's nice, I guess

#endif
Three instruction encoding sizes:  16-bit, 32-bit, and 48-bit

The instruction group is a 3-bit field, the 3 most significant bits of the
first 16-bits.

Group 0 Instructions, for example, use 000 as their group identifier.

GROUP_HEADER(0)
000o oooo aaaa bbbb
	
	DESCRIBE_OP
	DESCRIBE_RA (destination register usually)
	DESCRIBE_RB
	
	DESCRIBE_INSTRUCTIONS
		// ARG_REG(A) = ARG_REG(A) + ARG_REG(B)
		INSTR_RA_RB(add)
		
		// ARG_REG(A) = ARG_REG(A) + ARG_REG(B) + ARG_CARRY
		// Add with carry
		INSTR_RA_RB(adc)
		
		// ARG_REG(A) = ARG_REG(A) - ARG_REG(B)
		INSTR_RA_RB(sub)
		
		// ARG_REG(A) = ARG_REG(A) + (~ARG_REG(B)) + ARG_CARRY
		// Subtract with borrow (6502 style)
		INSTR_RA_RB(sbc)
		
		
		
		// ARG_REG(A) = ARG_REG(B) - ARG_REG(A)
		INSTR_RA_RB(rsb)
		
		// ARG_REG(A) = ARG_REG(A) * ARG_REG(B)
		INSTR_RA_RB(mul)
		
		// ARG_REG(A) &= ARG_REG(B)
		INSTR_RA_RB(and)
		
		// ARG_REG(A) |= ARG_REG(B)
		FLAGS_N_AND_Z
		INSTR_RA_RB(or)
		
		
		
		// ARG_REG(A) ^= ARG_REG(B)
		INSTR_RA_RB(xor)
		
		// Logical shift left
		// ARG_REG(A) <<= ARG_REG(B)
		INSTR_RA_RB(lsl)
		
		// Logical shift right
		INSTR_RA_RB(lsr)
		
		// Arithmetic shift right
		INSTR_RA_RB(asr)
		
		
		
		DESCRIBE_ROTATE_NOT_THROUGH_CARRY(left,ARG_REG(B))
		INSTR_RA_RB(rol)
		
		DESCRIBE_ROTATE_NOT_THROUGH_CARRY(right,ARG_REG(B))
		INSTR_RA_RB(ror)
		
		DESCRIBE_ROTATE_THROUGH_CARRY(left)
		FLAGS_ONLY(C)
		INSTR_RA_RB(rlc)
		
		DESCRIBE_ROTATE_THROUGH_CARRY(right)
		FLAGS_ONLY(C)
		INSTR_RA_RB(rrc)
		
		
		
		// ARG_REG(A) = Sign extend of low 16 bits in ARG_REG(B)
		// Note that the high 16 bits of ARG_REG(B) are ignored
		INSTR_RA_RB(seh)
		
		// ARG_REG(A) = Sign extend of low 8 bits in ARG_REG(B)
		INSTR_RA_RB(seb)
		
		// Push registers ARG_REG(A) and ARG_REG(b) (as a pair) onto the 
		// stack (in that order)
		INSTR_RA_RB(pushp)
		
		// Pop two 32-bit values off the stack, storing the first popped
		// value into ARG_REG(B) and the second popped value into ARG_REG(A)
		INSTR_RA_RB(popp)
		
		
		
		// Push flags as 8-bit value onto the stack (high 4 bits of pushed
		// value are set to zero before the push)
		INSTR_NO_ARGS(pushf)
		
		// Pop 8-bit value from the stack and store low 4 bits to flags
		INSTR_NO_ARGS(popf)
		
		RESERVED
		
		// Copy pc to ARG_REG(A) (this can be used for pc-relative loads
		// and stores)
		INSTR_RA(cpyfrpc)
		
		
		
		
		DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B)))
		INSTR_RA_RB(jumpx)
		
		DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B)))
		DESCRIBE_CALL_RETURN_ADDRESS
		INSTR_RA_RB(callx)
		
		// ENable Interrupts
		INSTR_NO_ARGS(eni)
		
		// DIsable Interrupts
		INSTR_NO_ARGS(dii)
		
		
		
		// Set the PC to interrupt RETurn address and enable Interrupts
		INSTR_NO_ARGS(reti)
		
		// Set the PC to the Interrupt Return Address, but DON'T enable
		// interrupts
		INSTR_NO_ARGS(jumpira)
		
		// Swap the Interrupt Return Address and ARG_REG(A)
		INSTR_RA(swpira)
		
		// Copy the Interrupt Return Address to ARG_REG(A)
		INSTR_RA(cpyira)
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS(ARG_REG(B))
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(jump,ARG_REG(B))
		//PSEUDO_INSTR_RB(jump)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_CALL_DESTINATION_ADDRESS(ARG_REG(B))
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(call,ARG_REG(B))
		//PSEUDO_INSTR_RB(call)
		


GROUP_HEADER(1)
001o oooo aaaa bbbb
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	
	DESCRIBE_INSTRUCTIONS
#define __TEMP_LDST_INSTR_TYPE INSTR_RA_RB
		GEN_LDST_NO_SUFFIX(in ARG_FOR_LDST_NON_INDEXED)
#undef __TEMP_LDST_INSTR_TYPE
		
		
		RESERVED
		RESERVED
		
		RESERVED
		RESERVED
		
		
		
		// Add 4 to ARG_REG(B), then load from address in ARG_REG(B) into
		// ARG_REG(A)
		// LoaD Register, Add Before
		INSTR_RA_RB(ldrab)
		
		// Store ARG_REG(A) to address in ARG_REG(B), then subtract 4 from
		// ARG_REG(B)
		// STore Register, Subtract After
		INSTR_RA_RB(strsa)
		
		RESERVED
		RESERVED
		
		
		
		// Clear ARG_REG(A), then CoPY FRom Flags to ARG_REG(A)
		INSTR_RA(cpyfrf)
		
		// Copy to flags from ARG_REG(A)
		FLAGS_ALL
		INSTR_RA(cpytof)
		
		RESERVED
		RESERVED
		
		
		
		RESERVED
		
		RESERVED
		
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED


GROUP_HEADER(2)
010o oooo aaaa bbbb  iiii iiii iiii iiii
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_IMM(16)
	
	DESCRIBE_INSTRUCTIONS
		// ARG_REG(A) = ARG_REG(B) + IMM_ZERO_EXTENDED
		FLAGS_ALL
		INSTR_RA_RB_IMM(addi,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) + IMM_ZERO_EXTENDED + ARG_CARRY
		// Add with carry
		FLAGS_ALL
		INSTR_RA_RB_IMM(adci,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) - IMM_ZERO_EXTENDED
		FLAGS_ALL
		INSTR_RA_RB_IMM(subi,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) + (~IMM_ZERO_EXTENDED) + ARG_CARRY
		// Subtract with borrow (6502 style)
		FLAGS_ALL
		INSTR_RA_RB_IMM(sbci,ARG_IMM)
		
		
		
		// ARG_REG(A) = IMM_ZERO_EXTENDED - ARG_REG(B)
		FLAGS_ALL
		INSTR_RA_RB_IMM(rsbi,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) * IMM_ZERO_EXTENDED
		INSTR_RA_RB_IMM(muli,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) & IMM_ZERO_EXTENDED
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(andi,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) | IMM_ZERO_EXTENDED
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(ori,ARG_IMM)
		
		
		
		// ARG_REG(A) = ARG_REG(B) ^ IMM_ZERO_EXTENDED
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(xori,ARG_IMM)
		
		// Logical shift left, by IMM_ZERO_EXTENDED bits
		ARG_REG(A) = ARG_REG(B) << IMM_ZERO_EXTENDED
		INSTR_RA_RB_IMM(lsli,ARG_IMM)
		
		// Logical shift right, by IMM_ZERO_EXTENDED bits
		INSTR_RA_RB_IMM(lsri,ARG_IMM)
		
		// Arithmetic shift right, by IMM_ZERO_EXTENDED bits
		INSTR_RA_RB_IMM(asri,ARG_IMM)
		
		
		
		DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(left,IMM_ZERO_EXTENDED)
		INSTR_RA_RB_IMM(roli,ARG_IMM)
		
		DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(right,IMM_ZERO_EXTENDED)
		INSTR_RA_RB_IMM(rori,ARG_IMM)
		
		// Branch always, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bra,ARG_IMM)
		
		// Branch when Z == 0, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bne,ARG_IMM)
		
		
		
		// Branch when Z == 1, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(beq,ARG_IMM)
		
		// Branch when C == 0 [unsigned less than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bcc,ARG_IMM)
		
		// Branch when C == 1 [unsigned greater than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bcs,ARG_IMM)
		
		// Branch when ( C == 0 or Z == 1 ) [unsigned less than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bls,ARG_IMM)
		
		
		
		// Branch when ( C == 1 and Z == 0 ) [unsigned greater than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bhi,ARG_IMM)
		
		// Branch when N == 0, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bpl,ARG_IMM)
		
		// Branch when N == 1, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bmi,ARG_IMM)
		
		// Branch when V == 0, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bvc,ARG_IMM)
		
		
		
		// Branch when V == 1, 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bvs,ARG_IMM)
		
		// Branch when N == V [signed greater than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bge,ARG_IMM)
		
		// Branch when N != V [signed less than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(blt,ARG_IMM)
		
		// Branch when ( N == V and Z == 0 ) [signed greater than], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(bgt,ARG_IMM)
		
		
		
		// Branch when ( N != V or Z == 1 ) [signed less than or equal], 
		// DESCRIBE_BRANCH_TARGET
		INSTR_IMM(ble,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) & IMM_SIGN_EXTENDED
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(andsi,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) | IMM_SIGN_EXTENDED
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(orsi,ARG_IMM)
		
		// ARG_REG(A) = ARG_REG(B) ^ IMM_SIGN_EXTENDED
		FLAGS_N_AND_Z
		INSTR_RA_RB_IMM(xorsi,ARG_IMM)
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// Compare ARG_REG(B) to IMM_ZERO_EXTENDED
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(subi,ARG_REG(B),ARG_IMM)
		//// ARG_TEMP = ARG_REG(B) - IMM_ZERO_EXTENDED
		//FLAGS_ALL
		//PSEUDO_INSTR_RB_IMM(cmpi,ARG_IMM)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// Compare ARG_REG(B) to negated IMM_ZERO_EXTENDED
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(addi,ARG_REG(B),ARG_IMM)
		//// ARG_TEMP = ARG_REG(B) - (-IMM_ZERO_EXTENDED)
		//FLAGS_ALL
		//PSEUDO_INSTR_RB_IMM(cmni,ARG_IMM)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// Copy Negated
		DESCRIBE_PSEUDO_INSTR_ENCODING(rsbi,ARG_REG(A)\, ARG_REG(B)\, 0)
		//// ARG_REG(A) = -ARG_REG(B)
		//INSTR_RA_RB(cpn)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// Compare reversed with immediate value
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(rsbi,ARG_REG(B),ARG_IMM)
		//// ARG_TEMP = IMM_ZERO_EXTENDED - ARG_REG(B)
		//FLAGS_ALL
		//PSEUDO_INSTR_RB_IMM(cmri,ARG_IMM)
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(B) & IMM_ZERO_EXTENDED
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(andi,ARG_REG(B),ARG_IMM)
		//FLAGS_N_AND_Z
		//PSEUDO_INSTR_RB_IMM(tsti,ARG_IMM)


GROUP_HEADER(3)
011o oooo aaaa bbbb  cccc iiii iiii iiii
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_RC
	DESCRIBE_IMM(12)
	
	DESCRIBE_INSTRUCTIONS
#define __TEMP_LDST_INSTR_TYPE INSTR_RA_RB_RC_IMM
		GEN_LDST_WITH_SUFFIX(ARG_FOR_LDST_GENERIC_INDEXED(IMM_SIGN_EXTENDED),xx\,ARG_IMM)
#undef __TEMP_LDST_INSTR_TYPE
		
		
		// ARG_REG(A) = ARG_REG(B) + ARG_REG(C)
		FLAGS_ALL
		INSTR_RA_RB_RC(addt)
		
		// ARG_REG(A) = ARG_REG(B) + ARG_REG(C) + ARG_CARRY
		FLAGS_ALL
		INSTR_RA_RB_RC(adct)
		
		// ARG_REG(A) = ARG_REG(B) - ARG_REG(C)
		FLAGS_ALL
		INSTR_RA_RB_RC(subt)
		
		// ARG_REG(A) = ARG_REG(B) + (~ARG_REG(C)) + ARG_CARRY
		// Subtract with borrow (6502 style)
		FLAGS_ALL
		INSTR_RA_RB_RC(sbct)
		
		
		
		// ARG_REG(A) = ARG_REG(C) - ARG_REG(B)
		FLAGS_ALL
		INSTR_RA_RB_RC(rsbt)
		
		// ARG_REG(A) = ARG_REG(B) * ARG_REG(C)
		INSTR_RA_RB_RC(mult)
		
		// ARG_REG(A) = ARG_REG(B) & ARG_REG(C)
		FLAGS_N_AND_Z
		INSTR_RA_RB_RC(andt)
		
		// ARG_REG(A) = ARG_REG(B) | ARG_REG(C)
		FLAGS_N_AND_Z
		INSTR_RA_RB_RC(ort)
		
		
		
		// ARG_REG(A) = ARG_REG(B) ^ ARG_REG(C)
		FLAGS_N_AND_Z
		INSTR_RA_RB_RC(xort)
		
		// Logical shift left
		// ARG_REG(A) = ARG_REG(B) << ARG_REG(C)
		INSTR_RA_RB_RC(lslt)
		
		// Logical shift right
		INSTR_RA_RB_RC(lsrt)
		
		// Arithmetic shift right
		INSTR_RA_RB_RC(asrt)
		
		
		
		DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(left,ARG_REG(C))
		INSTR_RA_RB_RC(rolt)
		
		DESCRIBE_THREE_ARG_ROTATE_NOT_THROUGH_CARRY(right,ARG_REG(C))
		INSTR_RA_RB_RC(rort)
		
		// Fused multiply-add
		// ARG_REG(A) = ARG_REG(A) + (ARG_REG(B) * ARG_REG(C))
		INSTR_RA_RB_RC(fma)
		
		// Copy ARG_REG(C) to ARG_REG(A) and to ARG_REG(B)
		INSTR_RA_RB_RC(cpyp)
		
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(B) - ARG_REG(C)
		//FLAGS_ALL
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(subt,ARG_REG(B)\, ARG_REG(C))
		//PSEUDO_INSTR_RB_RC(cmp)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(B) - (-ARG_REG(C))
		//FLAGS_ALL
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(addt,ARG_REG(B)\, ARG_REG(C))
		//PSEUDO_INSTR_RB_RC(cmn)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(C) - ARG_REG(B)
		//FLAGS_ALL
		DESCRIBE_PSEUDO_INSTR_R0_EQ_RA_ENCODING(rsbt,ARG_REG(B)\, ARG_REG(C))
		//PSEUDO_INSTR_RB_RC(cmr)
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_TEMP = ARG_REG(B) & ARG_REG(C)
		DESCRIBE_PSEUDO_INSTR_T_ENCODING(andt,ARG_REG(B),ARG_REG(C))
		//FLAGS_N_AND_Z
		//PSEUDO_INSTR_RB_RC(tst)
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// Copy
		//// ARG_REG(A) = ARG_REG(C)
		DESCRIBE_PSEUDO_INSTR_ENCODING(cpyp,ARG_REG(A)\, ARG_REG(0)\, ARG_REG(C))
		//PSEUDO_INSTR_RA_RC(cpy)


GROUP_HEADER(4)
100o oooo aaaa bbbb  iiii iiii iiii iiii  iiii iiii iiii iiii
	
	DESCRIBE_OP
	DESCRIBE_RA
	DESCRIBE_RB
	DESCRIBE_IMM(32)
	
	DESCRIBE_INSTRUCTIONS
#define __TEMP_LDST_INSTR_TYPE INSTR_RA_RB_IMM
		GEN_LDST_WITH_SUFFIX(ARG_FOR_LDST_ABS_INDEXED,ax\,ARG_ABS)
#undef __TEMP_LDST_INSTR_TYPE
		
		
		
		DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B) + ARG_ABS))
		INSTR_RA_RB_IMM(jumpaxx,ARG_ABS)
		
		DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B) + ARG_ABS))
		DESCRIBE_CALL_RETURN_ADDRESS
		INSTR_RA_RB_IMM(callaxx,ARG_ABS)
		
		// ARG_REG(A) = 32-bit immediate, ARG_REG(B) = same 32-bit immediate, 
		INSTR_RA_RB_IMM(cpypi,ARG_IMM)
		
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		RESERVED
		RESERVED
		RESERVED
		RESERVED
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A) + ARG_ABS))
		DESCRIBE_PSEUDO_INSTR_ENCODING(jumpaxx,ARG_REG(A)\, ARG_REG(0)\, ARG_ABS)
		INSTR_RA_IMM(jumpax,ARG_ABS)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_ABS))
		DESCRIBE_PSEUDO_INSTR_ENCODING(jumpaxx,ARG_REG(0)\, ARG_REG(0)\, ARG_ABS)
		INSTR_IMM(jumpa,ARG_ABS)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B)))
		DESCRIBE_PSEUDO_INSTR_ENCODING(jumpaxx,ARG_REG(A)\, ARG_REG(B)\, 0)
		INSTR_RA_RB(jumpxx)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_JUMP_DESTINATION_ADDRESS((ARG_REG(A)))
		DESCRIBE_PSEUDO_INSTR_ENCODING(jumpaxx,ARG_REG(A)\, ARG_REG(0)\, 0)
		INSTR_RA(jumpx)
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_REG(A) + ARG_ABS))
		//DESCRIBE_CALL_RETURN_ADDRESS
		DESCRIBE_PSEUDO_INSTR_ENCODING(callaxx,ARG_REG(A)\, ARG_REG(0)\, ARG_ABS)
		INSTR_RA_IMM(callax,ARG_ABS)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_ABS))
		//DESCRIBE_CALL_RETURN_ADDRESS
		DESCRIBE_PSEUDO_INSTR_ENCODING(callaxx,ARG_REG(0)\, ARG_REG(0)\, ARG_ABS)
		INSTR_IMM(calla,ARG_ABS)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_REG(A) + ARG_REG(B)))
		//DESCRIBE_CALL_RETURN_ADDRESS
		DESCRIBE_PSEUDO_INSTR_ENCODING(callaxx,ARG_REG(A)\, ARG_REG(B)\, ARG_ABS)
		INSTR_RA_RB(callxx)
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//DESCRIBE_CALL_DESTINATION_ADDRESS((ARG_ABS))
		//DESCRIBE_CALL_RETURN_ADDRESS
		DESCRIBE_PSEUDO_INSTR_ENCODING(callaxx,ARG_REG(A)\, ARG_REG(0)\, 0)
		INSTR_RA(callx)
		
		
		
		DESCRIBE_PSEUDO_INSTRUCTION
		//// ARG_REG(A) = 32-bit immediate
		DESCRIBE_PSEUDO_INSTR_ENCODING(cpypi,ARG_REG(A)\, ARG_REG(0)\, ARG_IMM)
		//INSTR_RA_IMM(cpyi,ARG_IMM)
