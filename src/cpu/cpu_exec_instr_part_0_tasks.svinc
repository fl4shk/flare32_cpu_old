`ifndef cpu_exec_instr_part_0_tasks_svinc
`define cpu_exec_instr_part_0_tasks_svinc


task exec_group_0_instr_part_0;
	// Group 0 instructions always go to StWriteBack
	__state <= pkg_cpu::StWriteBack;

	// Load
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Ldr_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ldsb_LdStRaRb_0))
	begin
		prep_read(__instr_dec_out_buf.ldst_req_data_size, 
			__gprs[__instr_dec_out_buf.rb_index]);
		__temp[pkg_temp_ind_0::Ld_RaIndex] <= __instr_dec_out_buf.ra_index;
	end

	// Store
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Str_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Stb_LdStRaRb_0))
	begin
		// Don't need to keep track of anything for the next cycle
		prep_write(__instr_dec_out_buf.ldst_req_data_size, 
			__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index]);
	end

	// Non flags affecting two-register ALU operation
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Add_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ror_RaRb_0))
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index],
			ig02_nf_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
		__temp[pkg_temp_ind_0::AluOp_RaIndex]
			<= __instr_dec_out_buf.ra_index;
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddDotF_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rrc_RaRb_0))
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index],
			ig02_f_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
		__temp[pkg_temp_ind_0::AluOp_RaIndex]
			<= __instr_dec_out_buf.ra_index;
	end

	// Enable/disable interrupts
	else if (__instr_dec_out_buf.oper == pkg_cpu::Eni_NoArgs_0)
	begin
		// Save doing this for the writeback stage
		//__spec_regs.ints_enabled <= 1;

		__temp[pkg_temp_ind_0::Eni_Ie] <= 1;
	end

	else if (__instr_dec_out_buf.oper == pkg_cpu::Dii_NoArgs_0)
	begin
		// Save doing this for the writeback stage
		//__spec_regs.ints_enabled <= 0;
		__temp[pkg_temp_ind_0::Dii_Ie] <= 0;
	end


	// Return from interrupt (enables interrupts in the process)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Reti_NoArgs_0)
	begin
		// Save doing this for the writeback stage
		//__spec_regs.pc <= __spec_regs.ira;
		//__spec_regs.ints_enabled <= 1;
		__temp[pkg_temp_ind_0::Reti_Ira] <= __spec_regs.ira;
		__temp[pkg_temp_ind_0::Reti_Ie]<= 1;
	end

	// Jump to the Interrupt Return Address without affecting the status of
	// whether interrupts are enabled
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jump_Ira_0)
	begin
		// Save doing this for the writeback stage
		//__spec_regs.pc <= __spec_regs.ira;
		//__temp[0] <= __spec_regs.ira;
		__temp[pkg_temp_ind_0::JumpIra_Ira] <= __spec_regs.ira;
	end

	// cpy rA, ira
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaIra_0)
	begin
		// Save doing this for the writeback stage
		// __gprs[__instr_dec_out_buf.ra_index] <= __spec_regs.ira;
		//__temp[0] <= __spec_regs.ira;
		__temp[pkg_temp_ind_0::CpyRaIra_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::CpyRaIra_Ira] <= __spec_regs.ira;
	end

	// cpy ira, rA
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_IraRa_0)
	begin
		// Save doing this for the writeback stage
		// __spec_regs.ira <= __gprs[__instr_dec_out_buf.ra_index];
		//__temp[0] <= __gprs[__instr_dec_out_buf.ra_index];
		__temp[pkg_temp_ind_0::CpyIraRa_Ra] 
			<= __gprs[__instr_dec_out_buf.ra_index];
	end


	// push/pop flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Push_Flags_0)
	begin
		__temp[pkg_temp_ind_0::PushFlags_Sp]
			<= __gprs[pkg_cpu::sp_reg_index];
		__temp[pkg_temp_ind_0::PushFlags_Flags] <= __spec_regs.flags;
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Pop_Flags_0)
	begin
		__temp[pkg_temp_ind_0::PopFlags_Sp]
			<= __gprs[pkg_cpu::sp_reg_index];
	end


	// cpy rA, flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaFlags_0)
	begin
		__temp[pkg_temp_ind_0::CpyRaFlags_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::CpyRaFlags_Flags] <= __spec_regs.flags;
	end

	// cpy flags, rA
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_FlagsRa_0)
	begin
		__temp[pkg_temp_ind_0::CpyFlagsRa_Ra]
			<= __gprs[__instr_dec_out_buf.ra_index];
	end

	// call/jump to address contained in (rA + rB)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Callx_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::CallRaRb_Dst] 
			<= callx_or_jumpx_dst_adder_out;
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jumpx_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::CallRaRb_Dst] 
			<= callx_or_jumpx_dst_adder_out;
	end

	// cpy rA, pc
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaPc_0)
	begin
		__temp[pkg_temp_ind_0::CpyRaPc_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::CpyRaPc_Pc] <= __spec_regs.pc;
	end

	// cpy rA, rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::CpyRaRb_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::CpyRaRb_Rb]
			<= __gprs[__instr_dec_out_buf.rb_index];
	end

	// Sign extend
	else if (__instr_dec_out_buf.oper == pkg_cpu::Seh_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::SehRaRb_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::SehRaRb_Rb]
			<= __gprs[__instr_dec_out_buf.rb_index];
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Seb_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::SebRaRb_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::SebRaRb_Rb]
			<= __gprs[__instr_dec_out_buf.rb_index];
	end

	// Compare rA to rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cmp_RaRb_0)
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index], pkg_cpu::Alu_Sub);
	end
endtask

task exec_group_1_instr_part_0;
	// Non flags affecting ALU operations with zero-extended 16-bit
	// immediate
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Addi_RaRbUImm16_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rori_RaRbUImm16_1))
	begin
		init_alu(__gprs[__instr_dec_out_buf.rb_index],
			__instr_dec_out_buf.imm_val_u16,
			__instr_dec_out_buf.oper[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
		__temp[pkg_temp_ind_1::AluOp_RaIndex]
			<= __instr_dec_out_buf.ra_index;
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddiDotF_RaRbUImm16_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::RoriDotF_RaRbUImm16_1))
	begin
		init_alu(__gprs[__instr_dec_out_buf.rb_index],
			__instr_dec_out_buf.imm_val_u16,
			ig1_f_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
		__temp[pkg_temp_ind_1::AluOp_RaIndex]
			<= __instr_dec_out_buf.ra_index;
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Bra_Branch_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ble_Branch_1))
	begin
		__temp[pkg_temp_ind_1::BranchOp_Dst] <= pc_addthree_branch_out;

		case (branch_taken_oc_out)
			// Bra_Branch_1
			`CPU_WORD_WIDTH'd0:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] <= 1;
			end

			// Bnv_Branch_1
			`CPU_WORD_WIDTH'd1:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] <= 0;
			end

			// Bne_Branch_1
			`CPU_WORD_WIDTH'd2:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
					<= (!__spec_regs.flags[pkg_cpu::FlagZ]);
			end

			// Beq_Branch_1
			`CPU_WORD_WIDTH'd3:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
					<= (__spec_regs.flags[pkg_cpu::FlagZ]);
			end

			// Bcc_Branch_1
			`CPU_WORD_WIDTH'd4:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
					<= (!__spec_regs.flags[pkg_cpu::FlagC]);
			end

			// Bcs_Branch_1
			`CPU_WORD_WIDTH'd5:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
					<= (__spec_regs.flags[pkg_cpu::FlagC]);
			end

			// Bls_Branch_1
			// Branch when (C == 0 or Z == 1) [unsigned less than or
			// equal]
			`CPU_WORD_WIDTH'd6:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= ((!__spec_regs.flags[pkg_cpu::FlagC])
					|| (__spec_regs.flags[pkg_cpu::FlagZ]));
			end

			// Bhi_Branch_1
			// Branch when (C == 1 and Z == 0) [unsigned greater than]
			`CPU_WORD_WIDTH'd7:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= ((__spec_regs.flags[pkg_cpu::FlagC])
					&& (!__spec_regs.flags[pkg_cpu::FlagZ]));
			end

			// Bpl_Branch_1
			`CPU_WORD_WIDTH'd8:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (!__spec_regs.flags[pkg_cpu::FlagN]);
			end

			// Bmi_Branch_1
			`CPU_WORD_WIDTH'd9:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (__spec_regs.flags[pkg_cpu::FlagN]);
			end

			// Bvc_Branch_1
			`CPU_WORD_WIDTH'd10:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (!__spec_regs.flags[pkg_cpu::FlagV]);
			end

			// Bvs_Branch_1
			`CPU_WORD_WIDTH'd11:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (__spec_regs.flags[pkg_cpu::FlagV]);
			end

			// Bge_Branch_1
			// Branch when N == V [signed greater than or equal],
			`CPU_WORD_WIDTH'd12:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (__spec_regs.flags[pkg_cpu::FlagN]
					== __spec_regs.flags[pkg_cpu::FlagV]);
			end

			// Blt_Branch_1
			// Branch when N != V [signed less than]
			`CPU_WORD_WIDTH'd13:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (__spec_regs.flags[pkg_cpu::FlagN]
					!= __spec_regs.flags[pkg_cpu::FlagV]);
			end

			// Bgt_Branch_1
			// Branch when (N == V and Z == 0) [signed greater than]
			`CPU_WORD_WIDTH'd14:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= ((__spec_regs.flags[pkg_cpu::FlagN]
					== __spec_regs.flags[pkg_cpu::FlagV])
					&& (!__spec_regs.flags[pkg_cpu::FlagZ]));
			end

			// Ble_Branch_1
			// Branch when (N != V or Z == 1) [signed less than or equal]
			`CPU_WORD_WIDTH'd15:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= ((__spec_regs.flags[pkg_cpu::FlagN]
					!= __spec_regs.flags[pkg_cpu::FlagV])
					|| (__spec_regs.flags[pkg_cpu::FlagZ]));
			end


			default:
			begin
				$display("Branch Taken Eek!");
			end
		endcase

	end

endtask

task exec_group_2_instr_part_0;
endtask

task exec_group_3_instr_part_0;
endtask


`endif		// cpu_exec_instr_part_0_tasks_svinc
