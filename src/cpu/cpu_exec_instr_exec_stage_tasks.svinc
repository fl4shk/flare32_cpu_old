`ifndef cpu_exec_instr_exec_stage_tasks_svinc
`define cpu_exec_instr_exec_stage_tasks_svinc

task exec_comb_logic_group_0_instr_exec_stage;
	// Load
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Ldr_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ldsb_LdStRaRb_0))
	begin
		prep_read(__instr_dec_out_buf.ldst_req_data_size, 
			__gprs[__instr_dec_out_buf.rb_index]);
	end

	// Store
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Str_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Stb_LdStRaRb_0))
	begin
		// Don't need to keep track of anything for the next cycle
		prep_write(__instr_dec_out_buf.ldst_req_data_size, 
			__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index]);
	end

	// Non flags affecting two-register ALU operation
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Add_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ror_RaRb_0))
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index],
			ig02_nf_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddDotF_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rrc_RaRb_0))
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index],
			ig02_f_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
	end

	//// Enable/disable interrupts
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Eni_NoArgs_0)
	//begin
	//end

	//else if (__instr_dec_out_buf.oper == pkg_cpu::Dii_NoArgs_0)
	//begin
	//end


	//// Return from interrupt (enables interrupts in the process)
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Reti_NoArgs_0)
	//begin
	//end

	//// Jump to the Interrupt Return Address without affecting the status of
	//// whether interrupts are enabled
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Jump_Ira_0)
	//begin
	//end

	//// cpy rA, ira
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaIra_0)
	//begin
	//end

	//// cpy ira, rA
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_IraRa_0)
	//begin
	//end


	// push/pop flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Push_Flags_0)
	begin
		// sp -= 1;
		// [sp] = flags;
		init_alu(__gprs[pkg_cpu::sp_reg_index], 1, pkg_cpu::Alu_Sub);
		prep_write(pkg_cpu::ReqDataSz8, __spec_regs.flags, alu_out.out);
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Pop_Flags_0)
	begin
		// flags = [sp];
		// sp += 1;
		init_alu(__gprs[pkg_cpu::sp_reg_index], 1, pkg_cpu::Alu_Add);
		prep_read(pkg_cpu::ReqDataSz8, __gprs[pkg_cpu::sp_reg_index]);
	end


	//// cpy rA, flags
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaFlags_0)
	//begin
	//end

	//// cpy flags, rA
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_FlagsRa_0)
	//begin
	//end

	// call/jump to address contained in (rA + rB)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Callx_RaRb_0)
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index], pkg_cpu::Alu_Add);
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jumpx_RaRb_0)
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index], pkg_cpu::Alu_Add);
	end

	//// cpy rA, pc
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaPc_0)
	//begin
	//end

	//// cpy rA, rB
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaRb_0)
	//begin
	//end

	//// Sign extend
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Seh_RaRb_0)
	//begin
	//end
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Seb_RaRb_0)
	//begin
	//end

	// Compare rA to rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cmp_RaRb_0)
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index],
			pkg_cpu::Alu_Sub);

	end
endtask

task exec_seq_logic_group_0_instr_exec_stage;
	// Group 0 instructions always go to StWriteBack
	__state <= pkg_cpu::StWriteBack;

	// Load
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Ldr_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ldsb_LdStRaRb_0))
	begin
		__temp[pkg_temp_ind_0::Ld_RaIndex] <= __instr_dec_out_buf.ra_index;
	end

	// Store
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Str_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Stb_LdStRaRb_0))
	begin
	end

	// Non flags affecting two-register ALU operation
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Add_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ror_RaRb_0))
	begin
		__temp[pkg_temp_ind_0::AluOp_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::AluOp_AluOut] <= alu_out.out;
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddDotF_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rrc_RaRb_0))
	begin
		__temp[pkg_temp_ind_0::AluDotFOp_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::AluDotFOp_AluOut] <= alu_out.out;
		__temp[pkg_temp_ind_0::AluDotFOp_FlagsOut] <= alu_out.flags;
	end

	// Enable/disable interrupts
	else if (__instr_dec_out_buf.oper == pkg_cpu::Eni_NoArgs_0)
	begin
		__temp[pkg_temp_ind_0::Eni_Ie] <= 1;
	end

	else if (__instr_dec_out_buf.oper == pkg_cpu::Dii_NoArgs_0)
	begin
		__temp[pkg_temp_ind_0::Dii_Ie] <= 0;
	end


	// Return from interrupt (enables interrupts in the process)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Reti_NoArgs_0)
	begin
		__temp[pkg_temp_ind_0::Reti_Ira] <= __spec_regs.ira;
		__temp[pkg_temp_ind_0::Reti_Ie]<= 1;
	end

	// Jump to the Interrupt Return Address without affecting the status of
	// whether interrupts are enabled
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jump_Ira_0)
	begin
		__temp[pkg_temp_ind_0::JumpIra_Ira] <= __spec_regs.ira;
	end

	// cpy rA, ira
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaIra_0)
	begin
		__temp[pkg_temp_ind_0::CpyRaIra_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::CpyRaIra_Ira] <= __spec_regs.ira;
	end

	// cpy ira, rA
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_IraRa_0)
	begin
		__temp[pkg_temp_ind_0::CpyIraRa_Ra] 
			<= __gprs[__instr_dec_out_buf.ra_index];
	end


	// push/pop flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Push_Flags_0)
	begin
		// sp -= 1;
		// [sp] = flags;
		__temp[pkg_temp_ind_0::PushFlags_NewSp] <= alu_out.out;
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Pop_Flags_0)
	begin
		// flags = [sp];
		// sp += 1;
		__temp[pkg_temp_ind_0::PopFlags_NewSp] <= alu_out.out;
	end


	// cpy rA, flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaFlags_0)
	begin
		__temp[pkg_temp_ind_0::CpyRaFlags_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::CpyRaFlags_Flags]
			<= __spec_regs.flags;
	end

	// cpy flags, rA
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_FlagsRa_0)
	begin
		__temp[pkg_temp_ind_0::CpyFlagsRa_Ra]
			<= __gprs[__instr_dec_out_buf.ra_index];
	end



	// call/jump to address contained in (rA + rB)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Callx_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::CallxRaRb_Dst] <= alu_out.out;
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jumpx_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::JumpxRaRb_Dst] <= alu_out.out;
	end



	// cpy rA, pc
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaPc_0)
	begin
		__temp[pkg_temp_ind_0::CpyRaPc_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::CpyRaPc_Pc] <= __spec_regs.pc;
	end

	// cpy rA, rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::CpyRaRb_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::CpyRaRb_Rb]
			<= __gprs[__instr_dec_out_buf.rb_index];
	end

	// Sign extend
	else if (__instr_dec_out_buf.oper == pkg_cpu::Seh_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::SehRaRb_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::SehRaRb_SehOut] <= ig0_seh_signext16_out;
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Seb_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::SebRaRb_RaIndex]
			<= __instr_dec_out_buf.ra_index;
		__temp[pkg_temp_ind_0::SebRaRb_SebOut] <= ig0_seb_signext8_out;
	end

	// Compare rA to rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cmp_RaRb_0)
	begin
		__temp[pkg_temp_ind_0::CmpRaRb_NewFlags] <= alu_out.flags;
	end
endtask

task exec_comb_logic_group_1_instr_exec_stage;

endtask

task exec_seq_logic_group_1_instr_exec_stage;
	// Non flags affecting ALU operations with zero-extended 16-bit
	// immediate
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Addi_RaRbUImm16_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rori_RaRbUImm16_1))
	begin
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddiDotF_RaRbUImm16_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::RoriDotF_RaRbUImm16_1))
	begin
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Bra_Branch_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ble_Branch_1))
	begin
		__temp[pkg_temp_ind_1::BranchOp_Dst] <= pc_addthree_branch_out;

		case (branch_taken_oc_out)
			// Bra_Branch_1
			`CPU_WORD_WIDTH'd0:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] <= 1;
			end

			// Bnv_Branch_1
			`CPU_WORD_WIDTH'd1:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] <= 0;
			end

			// Bne_Branch_1
			`CPU_WORD_WIDTH'd2:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
					<= (!__spec_regs.flags[pkg_cpu::FlagZ]);
			end

			// Beq_Branch_1
			`CPU_WORD_WIDTH'd3:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
					<= (__spec_regs.flags[pkg_cpu::FlagZ]);
			end

			// Bcc_Branch_1
			`CPU_WORD_WIDTH'd4:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
					<= (!__spec_regs.flags[pkg_cpu::FlagC]);
			end

			// Bcs_Branch_1
			`CPU_WORD_WIDTH'd5:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
					<= (__spec_regs.flags[pkg_cpu::FlagC]);
			end

			// Bls_Branch_1
			// Branch when (C == 0 or Z == 1) [unsigned less than or
			// equal]
			`CPU_WORD_WIDTH'd6:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= ((!__spec_regs.flags[pkg_cpu::FlagC])
					|| (__spec_regs.flags[pkg_cpu::FlagZ]));
			end

			// Bhi_Branch_1
			// Branch when (C == 1 and Z == 0) [unsigned greater than]
			`CPU_WORD_WIDTH'd7:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= ((__spec_regs.flags[pkg_cpu::FlagC])
					&& (!__spec_regs.flags[pkg_cpu::FlagZ]));
			end

			// Bpl_Branch_1
			`CPU_WORD_WIDTH'd8:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (!__spec_regs.flags[pkg_cpu::FlagN]);
			end

			// Bmi_Branch_1
			`CPU_WORD_WIDTH'd9:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (__spec_regs.flags[pkg_cpu::FlagN]);
			end

			// Bvc_Branch_1
			`CPU_WORD_WIDTH'd10:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (!__spec_regs.flags[pkg_cpu::FlagV]);
			end

			// Bvs_Branch_1
			`CPU_WORD_WIDTH'd11:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (__spec_regs.flags[pkg_cpu::FlagV]);
			end

			// Bge_Branch_1
			// Branch when N == V [signed greater than or equal],
			`CPU_WORD_WIDTH'd12:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (__spec_regs.flags[pkg_cpu::FlagN]
					== __spec_regs.flags[pkg_cpu::FlagV]);
			end

			// Blt_Branch_1
			// Branch when N != V [signed less than]
			`CPU_WORD_WIDTH'd13:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= (__spec_regs.flags[pkg_cpu::FlagN]
					!= __spec_regs.flags[pkg_cpu::FlagV]);
			end

			// Bgt_Branch_1
			// Branch when (N == V and Z == 0) [signed greater than]
			`CPU_WORD_WIDTH'd14:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= ((__spec_regs.flags[pkg_cpu::FlagN]
					== __spec_regs.flags[pkg_cpu::FlagV])
					&& (!__spec_regs.flags[pkg_cpu::FlagZ]));
			end

			// Ble_Branch_1
			// Branch when (N != V or Z == 1) [signed less than or equal]
			`CPU_WORD_WIDTH'd15:
			begin
				__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
					<= ((__spec_regs.flags[pkg_cpu::FlagN]
					!= __spec_regs.flags[pkg_cpu::FlagV])
					|| (__spec_regs.flags[pkg_cpu::FlagZ]));
			end


			default:
			begin
				$display("Branch Taken Eek!");
			end
		endcase
	end

	// rA <= rB ^ (sign-extended 16-bit immediate)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Xorsi_RaRbSImm16_1)
	begin
	end

	// rA[31:16] <= (zero-extended 16-bit immediate)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Lui_RaUImm16_1)
	begin
	end

endtask

task exec_comb_logic_group_2_instr_exec_stage;

endtask
task exec_seq_logic_group_2_instr_exec_stage;
endtask

task exec_comb_logic_group_3_instr_exec_stage;

endtask
task exec_seq_logic_group_3_instr_exec_stage;
endtask


`endif		// cpu_exec_instr_exec_stage_tasks_svinc
