`ifndef cpu_exec_instr_exec_stage_tasks_svinc
`define cpu_exec_instr_exec_stage_tasks_svinc

task set_wbs_ra;
	input can_write;
	input [`CPU_WORD_MSB_POS:0] n_data;

	__wbs_ra <= {can_write, __gprs[__instr_dec_out_buf.ra_index],
		n_data, __instr_dec_out_buf.ra_index};
endtask
task set_wbs_rb;
	input can_write;
	input [`CPU_WORD_MSB_POS:0] n_data;

	__wbs_rb <= {can_write, __gprs[__instr_dec_out_buf.rb_index],
		n_data, __instr_dec_out_buf.rb_index};
endtask
task set_wbs_rc;
	input can_write;
	input [`CPU_WORD_MSB_POS:0] n_data;

	__wbs_rc <= {can_write, __gprs[__instr_dec_out_buf.rc_index], n_data, 
		__instr_dec_out_buf.rc_index};
endtask
task set_wbs_sp;
	input can_write;
	input [`CPU_WORD_MSB_POS:0] n_data;

	__wbs_sp <= {can_write, __gprs[pkg_cpu::sp_reg_index], n_data, 
		pkg_cpu::sp_reg_index};
endtask

task set_wbs_pc;
	input can_write;
	input [`CPU_WORD_MSB_POS:0] n_data;

	__wbs_pc <= {can_write, __spec_regs.pc, n_data, -32'd1};
endtask

task set_wbs_ira;
	input can_write;
	input [`CPU_WORD_MSB_POS:0] n_data;

	__wbs_ira <= {can_write, __spec_regs.ira, n_data, -32'd1};
endtask

task set_wbs_flags;
	input can_write;
	input [`CPU_WORD_MSB_POS:0] n_data;

	__wbs_flags <= {can_write, __spec_regs.flags, n_data, -32'd1};
endtask

task set_wbs_ints_enabled;
	input can_write;
	input [`CPU_WORD_MSB_POS:0] n_data;

	__wbs_ints_enabled 
		<= {can_write, __spec_regs.ints_enabled, n_data, -32'd1};
endtask




// Load
task exec_comb_logic_group_0_load;
	prep_read(__instr_dec_out_buf.ldst_req_data_size, 
		__gprs[__instr_dec_out_buf.rb_index]);
endtask

task exec_seq_logic_group_0_load;
	///__temp[pkg_temp_ind_0::Ld_RaIndex] <= __instr_dec_out_buf.ra_index;
	set_wbs_ra(1, 0);
endtask


// Store
task exec_comb_logic_group_0_store;
	// Don't need to keep track of anything for the next cycle
	prep_write(__instr_dec_out_buf.ldst_req_data_size, 
		__gprs[__instr_dec_out_buf.ra_index],
		__gprs[__instr_dec_out_buf.rb_index]);
endtask

task exec_seq_logic_group_0_store;
	// Do nothing
endtask


// Non flags affecting two-register ALU operation
task exec_comb_logic_group_0_nf_alu_op;
	init_alu(__gprs[__instr_dec_out_buf.ra_index],
		__gprs[__instr_dec_out_buf.rb_index],
		ig02_nf_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
endtask

task exec_seq_logic_group_0_nf_alu_op;
	//__temp[pkg_temp_ind_0::AluOp_RaIndex]
	//	<= __instr_dec_out_buf.ra_index;
	//__temp[pkg_temp_ind_0::AluOp_AluOut] <= alu_out.out;
	set_wbs_ra(1, alu_out.out);
endtask



task exec_comb_logic_group_0_f_alu_op;
	init_alu(__gprs[__instr_dec_out_buf.ra_index],
		__gprs[__instr_dec_out_buf.rb_index],
		ig02_f_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
endtask

task exec_seq_logic_group_0_f_alu_op;
	//__temp[pkg_temp_ind_0::AluDotFOp_RaIndex]
	//	<= __instr_dec_out_buf.ra_index;
	//__temp[pkg_temp_ind_0::AluDotFOp_AluOut] <= alu_out.out;
	//__temp[pkg_temp_ind_0::AluDotFOp_FlagsOut] <= alu_out.flags;
	set_wbs_ra(1, alu_out.out);
	set_wbs_flags(1, alu_out.flags);
endtask








task exec_comb_logic_group_0_instr_exec_stage;
	// Load
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Ldr_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ldsb_LdStRaRb_0))
	begin
		exec_comb_logic_group_0_load();
	end

	// Store
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Str_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Stb_LdStRaRb_0))
	begin
		//// Don't need to keep track of anything for the next cycle
		//prep_write(__instr_dec_out_buf.ldst_req_data_size, 
		//	__gprs[__instr_dec_out_buf.ra_index],
		//	__gprs[__instr_dec_out_buf.rb_index]);
		exec_comb_logic_group_0_store();
	end

	// Non flags affecting two-register ALU operation
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Add_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ror_RaRb_0))
	begin
		//init_alu(__gprs[__instr_dec_out_buf.ra_index],
		//	__gprs[__instr_dec_out_buf.rb_index],
		//	ig02_nf_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
		exec_comb_logic_group_0_nf_alu_op();
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddDotF_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rrc_RaRb_0))
	begin
		//init_alu(__gprs[__instr_dec_out_buf.ra_index],
		//	__gprs[__instr_dec_out_buf.rb_index],
		//	ig02_f_alu_oc_out[`CPU_ENUM_ALU_OPER_SIZE_MSB_POS:0]);
		exec_comb_logic_group_0_f_alu_op();
	end

	//// Enable/disable interrupts
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Eni_NoArgs_0)
	//begin
	//end

	//else if (__instr_dec_out_buf.oper == pkg_cpu::Dii_NoArgs_0)
	//begin
	//end


	//// Return from interrupt (enables interrupts in the process)
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Reti_NoArgs_0)
	//begin
	//end

	//// Jump to the Interrupt Return Address without affecting the status of
	//// whether interrupts are enabled
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Jump_Ira_0)
	//begin
	//end

	//// cpy rA, ira
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaIra_0)
	//begin
	//end

	//// cpy ira, rA
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_IraRa_0)
	//begin
	//end


	// push/pop flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Push_Flags_0)
	begin
		// sp -= 1;
		// [sp] = flags;
		init_alu(__gprs[pkg_cpu::sp_reg_index], 1, pkg_cpu::Alu_Sub);
		prep_write(pkg_cpu::ReqDataSz8, __spec_regs.flags, alu_out.out);
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Pop_Flags_0)
	begin
		// flags = [sp];
		// sp += 1;
		init_alu(__gprs[pkg_cpu::sp_reg_index], 1, pkg_cpu::Alu_Add);
		prep_read(pkg_cpu::ReqDataSz8, __gprs[pkg_cpu::sp_reg_index]);
	end


	//// cpy rA, flags
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaFlags_0)
	//begin
	//end

	//// cpy flags, rA
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_FlagsRa_0)
	//begin
	//end

	// call/jump to address contained in (rA + rB)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Callx_RaRb_0)
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index], pkg_cpu::Alu_Add);
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jumpx_RaRb_0)
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index], pkg_cpu::Alu_Add);
	end

	//// cpy rA, pc
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaPc_0)
	//begin
	//end

	//// cpy rA, rB
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaRb_0)
	//begin
	//end

	//// Sign extend
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Seh_RaRb_0)
	//begin
	//end
	//else if (__instr_dec_out_buf.oper == pkg_cpu::Seb_RaRb_0)
	//begin
	//end

	// Compare rA to rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cmp_RaRb_0)
	begin
		init_alu(__gprs[__instr_dec_out_buf.ra_index],
			__gprs[__instr_dec_out_buf.rb_index],
			pkg_cpu::Alu_Sub);

	end
endtask

task exec_seq_logic_group_0_instr_exec_stage;
	// Group 0 instructions always go to StWriteBack
	__state <= pkg_cpu::StWriteBack;

	// Load
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Ldr_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ldsb_LdStRaRb_0))
	begin
		//__temp[pkg_temp_ind_0::Ld_RaIndex] <= __instr_dec_out_buf.ra_index;
		exec_seq_logic_group_0_load();
	end

	// Store
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Str_LdStRaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Stb_LdStRaRb_0))
	begin
		exec_seq_logic_group_0_store();
	end

	// Non flags affecting two-register ALU operation
	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Add_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ror_RaRb_0))
	begin
		//__temp[pkg_temp_ind_0::AluOp_RaIndex]
		//	<= __instr_dec_out_buf.ra_index;
		//__temp[pkg_temp_ind_0::AluOp_AluOut] <= alu_out.out;
		exec_seq_logic_group_0_nf_alu_op();
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddDotF_RaRb_0)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rrc_RaRb_0))
	begin
		//__temp[pkg_temp_ind_0::AluDotFOp_RaIndex]
		//	<= __instr_dec_out_buf.ra_index;
		//__temp[pkg_temp_ind_0::AluDotFOp_AluOut] <= alu_out.out;
		//__temp[pkg_temp_ind_0::AluDotFOp_FlagsOut] <= alu_out.flags;
		exec_seq_logic_group_0_f_alu_op();
	end

	// Enable/disable interrupts
	else if (__instr_dec_out_buf.oper == pkg_cpu::Eni_NoArgs_0)
	begin
		//__temp[pkg_temp_ind_0::Eni_Ie] <= 1;
	end

	else if (__instr_dec_out_buf.oper == pkg_cpu::Dii_NoArgs_0)
	begin
		//__temp[pkg_temp_ind_0::Dii_Ie] <= 0;
	end


	// Return from interrupt (enables interrupts in the process)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Reti_NoArgs_0)
	begin
		//__temp[pkg_temp_ind_0::Reti_Ira] <= __spec_regs.ira;
		//__temp[pkg_temp_ind_0::Reti_Ie]<= 1;
	end

	// Jump to the Interrupt Return Address without affecting the status of
	// whether interrupts are enabled
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jump_Ira_0)
	begin
		//__temp[pkg_temp_ind_0::JumpIra_Ira] <= __spec_regs.ira;
	end

	// cpy rA, ira
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaIra_0)
	begin
		//__temp[pkg_temp_ind_0::CpyRaIra_RaIndex]
		//	<= __instr_dec_out_buf.ra_index;
		//__temp[pkg_temp_ind_0::CpyRaIra_Ira] <= __spec_regs.ira;
	end

	// cpy ira, rA
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_IraRa_0)
	begin
		//__temp[pkg_temp_ind_0::CpyIraRa_Ra] 
		//	<= __gprs[__instr_dec_out_buf.ra_index];
	end


	// push/pop flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Push_Flags_0)
	begin
		// sp -= 1;
		// [sp] = flags;
		//__temp[pkg_temp_ind_0::PushFlags_NewSp] <= alu_out.out;
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Pop_Flags_0)
	begin
		// flags = [sp];
		// sp += 1;
		//__temp[pkg_temp_ind_0::PopFlags_NewSp] <= alu_out.out;
	end


	// cpy rA, flags
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaFlags_0)
	begin
		//__temp[pkg_temp_ind_0::CpyRaFlags_RaIndex]
		//	<= __instr_dec_out_buf.ra_index;
		//__temp[pkg_temp_ind_0::CpyRaFlags_Flags]
		//	<= __spec_regs.flags;
	end

	// cpy flags, rA
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_FlagsRa_0)
	begin
		//__temp[pkg_temp_ind_0::CpyFlagsRa_Ra]
		//	<= __gprs[__instr_dec_out_buf.ra_index];
	end



	// call/jump to address contained in (rA + rB)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Callx_RaRb_0)
	begin
		//__temp[pkg_temp_ind_0::CallxRaRb_Dst] <= alu_out.out;
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Jumpx_RaRb_0)
	begin
		//__temp[pkg_temp_ind_0::JumpxRaRb_Dst] <= alu_out.out;
	end



	// cpy rA, pc
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaPc_0)
	begin
		//__temp[pkg_temp_ind_0::CpyRaPc_RaIndex]
		//	<= __instr_dec_out_buf.ra_index;
		//__temp[pkg_temp_ind_0::CpyRaPc_Pc] <= __spec_regs.pc;
	end

	// cpy rA, rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cpy_RaRb_0)
	begin
		//__temp[pkg_temp_ind_0::CpyRaRb_RaIndex]
		//	<= __instr_dec_out_buf.ra_index;
		//__temp[pkg_temp_ind_0::CpyRaRb_Rb]
		//	<= __gprs[__instr_dec_out_buf.rb_index];
	end

	// Sign extend
	else if (__instr_dec_out_buf.oper == pkg_cpu::Seh_RaRb_0)
	begin
		//__temp[pkg_temp_ind_0::SehRaRb_RaIndex]
		//	<= __instr_dec_out_buf.ra_index;
		//__temp[pkg_temp_ind_0::SehRaRb_SehOut] <= ig0_seh_signext16_out;
	end
	else if (__instr_dec_out_buf.oper == pkg_cpu::Seb_RaRb_0)
	begin
		//__temp[pkg_temp_ind_0::SebRaRb_RaIndex]
		//	<= __instr_dec_out_buf.ra_index;
		//__temp[pkg_temp_ind_0::SebRaRb_SebOut] <= ig0_seb_signext8_out;
	end

	// Compare rA to rB
	else if (__instr_dec_out_buf.oper == pkg_cpu::Cmp_RaRb_0)
	begin
		//__temp[pkg_temp_ind_0::CmpRaRb_NewFlags] <= alu_out.flags;
	end
endtask

task exec_comb_logic_group_1_instr_exec_stage;

endtask

task exec_seq_logic_group_1_instr_exec_stage;
	// Non flags affecting ALU operations with zero-extended 16-bit
	// immediate
	if ((__instr_dec_out_buf.oper >= pkg_cpu::Addi_RaRbUImm16_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Rori_RaRbUImm16_1))
	begin
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::AddiDotF_RaRbUImm16_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::RoriDotF_RaRbUImm16_1))
	begin
	end

	else if ((__instr_dec_out_buf.oper >= pkg_cpu::Bra_Branch_1)
		&& (__instr_dec_out_buf.oper <= pkg_cpu::Ble_Branch_1))
	begin
		//__temp[pkg_temp_ind_1::BranchOp_Dst] <= pc_addthree_branch_out;

		//case (branch_taken_oc_out)
		//	// Bra_Branch_1
		//	`CPU_WORD_WIDTH'd0:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken] <= 1;
		//	end

		//	// Bnv_Branch_1
		//	`CPU_WORD_WIDTH'd1:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken] <= 0;
		//	end

		//	// Bne_Branch_1
		//	`CPU_WORD_WIDTH'd2:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
		//			<= (!__spec_regs.flags[pkg_cpu::FlagZ]);
		//	end

		//	// Beq_Branch_1
		//	`CPU_WORD_WIDTH'd3:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
		//			<= (__spec_regs.flags[pkg_cpu::FlagZ]);
		//	end

		//	// Bcc_Branch_1
		//	`CPU_WORD_WIDTH'd4:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
		//			<= (!__spec_regs.flags[pkg_cpu::FlagC]);
		//	end

		//	// Bcs_Branch_1
		//	`CPU_WORD_WIDTH'd5:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken] 
		//			<= (__spec_regs.flags[pkg_cpu::FlagC]);
		//	end

		//	// Bls_Branch_1
		//	// Branch when (C == 0 or Z == 1) [unsigned less than or
		//	// equal]
		//	`CPU_WORD_WIDTH'd6:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= ((!__spec_regs.flags[pkg_cpu::FlagC])
		//			|| (__spec_regs.flags[pkg_cpu::FlagZ]));
		//	end

		//	// Bhi_Branch_1
		//	// Branch when (C == 1 and Z == 0) [unsigned greater than]
		//	`CPU_WORD_WIDTH'd7:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= ((__spec_regs.flags[pkg_cpu::FlagC])
		//			&& (!__spec_regs.flags[pkg_cpu::FlagZ]));
		//	end

		//	// Bpl_Branch_1
		//	`CPU_WORD_WIDTH'd8:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= (!__spec_regs.flags[pkg_cpu::FlagN]);
		//	end

		//	// Bmi_Branch_1
		//	`CPU_WORD_WIDTH'd9:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= (__spec_regs.flags[pkg_cpu::FlagN]);
		//	end

		//	// Bvc_Branch_1
		//	`CPU_WORD_WIDTH'd10:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= (!__spec_regs.flags[pkg_cpu::FlagV]);
		//	end

		//	// Bvs_Branch_1
		//	`CPU_WORD_WIDTH'd11:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= (__spec_regs.flags[pkg_cpu::FlagV]);
		//	end

		//	// Bge_Branch_1
		//	// Branch when N == V [signed greater than or equal],
		//	`CPU_WORD_WIDTH'd12:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= (__spec_regs.flags[pkg_cpu::FlagN]
		//			== __spec_regs.flags[pkg_cpu::FlagV]);
		//	end

		//	// Blt_Branch_1
		//	// Branch when N != V [signed less than]
		//	`CPU_WORD_WIDTH'd13:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= (__spec_regs.flags[pkg_cpu::FlagN]
		//			!= __spec_regs.flags[pkg_cpu::FlagV]);
		//	end

		//	// Bgt_Branch_1
		//	// Branch when (N == V and Z == 0) [signed greater than]
		//	`CPU_WORD_WIDTH'd14:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= ((__spec_regs.flags[pkg_cpu::FlagN]
		//			== __spec_regs.flags[pkg_cpu::FlagV])
		//			&& (!__spec_regs.flags[pkg_cpu::FlagZ]));
		//	end

		//	// Ble_Branch_1
		//	// Branch when (N != V or Z == 1) [signed less than or equal]
		//	`CPU_WORD_WIDTH'd15:
		//	begin
		//		__temp[pkg_temp_ind_1::BranchOp_BranchTaken]
		//			<= ((__spec_regs.flags[pkg_cpu::FlagN]
		//			!= __spec_regs.flags[pkg_cpu::FlagV])
		//			|| (__spec_regs.flags[pkg_cpu::FlagZ]));
		//	end


		//	default:
		//	begin
		//		$display("Branch Taken Eek!");
		//	end
		//endcase
	end

	// rA <= rB ^ (sign-extended 16-bit immediate)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Xorsi_RaRbSImm16_1)
	begin
	end

	// rA[31:16] <= (zero-extended 16-bit immediate)
	else if (__instr_dec_out_buf.oper == pkg_cpu::Lui_RaUImm16_1)
	begin
	end

endtask

task exec_comb_logic_group_2_instr_exec_stage;

endtask
task exec_seq_logic_group_2_instr_exec_stage;
endtask

task exec_comb_logic_group_3_instr_exec_stage;

endtask
task exec_seq_logic_group_3_instr_exec_stage;
endtask


`endif		// cpu_exec_instr_exec_stage_tasks_svinc
