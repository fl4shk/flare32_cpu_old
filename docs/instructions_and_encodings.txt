Three instruction encoding sizes:  16-bit, 32-bit, and 48-bit

The instruction group is a 3-bit field, the 3 most significant bits of the
first 16-bits.

Group 0 Instructions, for example, use 000 as their group identifier.

Group 0 Instructions
000o oooo aaaa bbbb
	
	o:  opcode
	a:  rA (destination register usually)
	b:  rB
	
	Instructions:
		// This instruction affects N, V, Z, and C flags.
		add rA, rB
		
		// Add with carry
		// This instruction affects N, V, Z, and C flags.
		adc rA, rB
		
		// This instruction affects N, V, Z, and C flags.
		sub rA, rB
		
		// Subtract with borrow (6502 style)
		// This instruction affects N, V, Z, and C flags.
		sbc rA, rB
		
		
		
		// This instruction ONLY affects flags.
		cmp rA, rB
		
		// rA *= rB
		mul rA, rB
		
		// This instruction affects the N and Z flags.
		and rA, rB
		
		// This instruction affects the N and Z flags.
		or rA, rB
		
		
		
		// This instruction affects the N and Z flags.
		xor rA, rB
		
		// Logical shift left
		lsl rA, rB
		
		// Logical shift right
		lsr rA, rB
		
		// Arithmetic shift right
		asr rA, rB
		
		
		
		// Rotate rA left (NOT through carry) by rB bits, then store result in rA.
		rol rA, rB
		
		// Rotate rA right (NOT through carry) by rB bits, then store result in rA.
		ror rA, rB
		
		// Rotate rA left (THROUGH carry) by 1 bit, ignoring rB, then store result in rA.
		// This instruction only affects the C flag.
		rlc rA
		
		// Rotate rA right (THROUGH carry) by 1 bit, ignoring rB, then store result in rA.
		// This instruction only affects the C flag.
		rrc rA
		
		
		
		// Load 32-bit value from address rB into rA.
		ldr rA, rB
		
		// Load zero-extended 16-bit value from address rB into rA.
		// This zero-extends the value.
		ldh rA, rB
		
		// Load sign-extended 16-bit value from address rB into rA.
		// This sign-extends the value.
		ldsh rA, rB
		
		// Load zero-extended 8-bit value from address rB into rA.
		// This zero-extends the value.
		ldb rA, rB
		
		
		
		// Load sign-extended 8-bit value from address rB into rA.
		// This sign-extends the value.
		ldsb rA, rB
		
		// Store 32-bit value in rA to address rB.
		str rA, rB
		
		// Store low 16 bits of rA to address rB.
		sth rA, rB
		
		// Store low 8 bits of rA to address rB.
		stb rA, rB
		
		
		
		// rA = Zero extend of low 16 bits in rB
		zeh rA, rB
		
		// rA = Sign extend of low 16 bits in rB
		seh rA, rB
		
		// rA = Zero extend of low 8 bits in rB
		zeb rA, rB
		
		// rA = Sign extend of low 8 bits in rB
		seb rA, rB
		
		
		
		// Copy (rA = rB)
		cpy rA, rB
		
		// Copy Negated (rA = -rB)
		cpn rA, rB
		
		// Copy Complemented (rA = ~rB)
		cpc rA, rB
		
		// Copy pc to rA (this can be used for pc-relative loads
		// and stores)
		cpyfrpc rA


Group 1 Instructions
001o oooo aaaa bbbb
	
	o:  opcode
	a:  rA
	b:  rB
	
	Instructions:
		// rA = rB + 1
		// This instruction affects N, V, Z, and C flags.
		inc rA, rB
		
		// rA = rB - 1
		// This instruction affects N, V, Z, and C flags.
		dec rA, rB
		
		// rA:rB = (64-bit zero-extend of rA) * (64-bit zero-extend of rB)
		// 
		// Note that rA will contain the high 32 bits of the 
		// unsigned 64-bit product
		// 
		// Note that rB will contain the low 32 bits of the 
		// unsigned 64-bit product
		// 
		umull rA, rB
		
		// rA:rB = (64-bit sign-extend of rA) * (64-bit sign-extend of rB)
		// 
		// Note that rA will contain the high 32 bits of the signed 
		// 64-bit product
		// 
		// Note that rB will contain the low 32 bits of the signed 
		// 64-bit product
		// 
		smull rA, rB
		
		
		
		// Set pc to destination address in rA.
		jump rA
		
		// Set pc to destination address in (rA + rB).
		jumpx rA, rB
		
		// Subroutine call using rA as destination address. 
		// The return address is stored in the link register (lr).
		call rA
		
		// Subroutine call using (rA + rB) as destination address. 
		// The return address is stored in the link register (lr).
		callx rA, rB
		
		
		
		// Push register rA onto the stack
		pushr rA
		
		// Pop 32-bit value off the stack into rA
		popr rA
		
		// Push registers rA and rb (as a pair) onto the 
		// stack (in that order)
		pushp rA, rB
		
		// Pop two 32-bit values off the stack, storing the first popped
		// value into rB and the second popped value into rA
		popp rA, rB
		
		
		
		// Push flags as 8-bit value onto the stack (high 4 bits of pushed value are set to zero before the push)
		pushf
		
		// Pop 8-bit value from the stack and store low 4 bits to flags
		popf
		
		// Clear rA, then CoPY FRom Flags to rA
		cpyfrf rA
		
		// Copy to flags from rA
		// This instruction affects N, V, Z, and C flags.
		cpytof rA
		
		
		
		// ENable Interrupts
		eni
		
		// DIsable Interrupts
		dii
		
		// Set the PC to interrupt RETurn address and enable Interrupts
		reti
		
		// Set the PC to the Interrupt Return Address, but DON'T enable
		// interrupts
		jumpira
		
		
		
		// Swap the Interrupt Return Address and rA
		swpira rA
		
		// Copy the Interrupt Return Address to rA
		cpyira rA
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.


Group 2 Instructions
010o oooo aaaa bbbb  iiii iiii iiii iiii
	
	o:  opcode
	a:  rA
	b:  rB
	i:  16-bit immediate value
	
	Instructions:
		// Load 32-bit value from address (rB + (sign-extended imm)) into rA.
		ldrxi rA, rB, imm
		
		// Load zero-extended 16-bit value from address (rB + (sign-extended imm)) into rA.
		ldhxi rA, rB, imm
		
		// Load sign-extended 16-bit value from address (rB + (sign-extended imm)) into rA.
		ldshxi rA, rB, imm
		
		// Load zero-extended 8-bit value from address (rB + (sign-extended imm)) into rA.
		ldbxi rA, rB, imm
		
		
		
		// Load sign-extended 8-bit value from address (rB + (sign-extended imm)) into rA.
		ldsbxi rA, rB, imm
		
		// Store 32-bit value in rA to address (rB + (sign-extended imm)).
		strxi rA, rB, imm
		
		// Store low 16 bits of rA to address (rB + (sign-extended imm)).
		sthxi rA, rB, imm
		
		// Store low 8 bits of rA to address (rB + (sign-extended imm)).
		stbxi rA, rB, imm
		
		
		
		// rA = rB + (sign-extended imm)
		// This instruction affects N, V, Z, and C flags.
		addsi rA, rB, imm
		
		// Logical shift left, by (zero-extended imm) bits
		lsli rA, rB, imm
		
		// Logical shift right, by (zero-extended imm) bits
		lsri rA, rB, imm
		
		// Arithmetic shift right, by (zero-extended imm) bits
		asri rA, rB, imm
		
		
		
		// Compare rA to (zero-extended imm)
		// This instruction ONLY affects flags.
		cmpi imm
		
		// Branch always, to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bra imm
		
		// Branch when Z == 0, to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bne imm
		
		// Branch when Z == 1, to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		beq imm
		
		
		
		// Branch when C == 0 [unsigned less than], 
		// to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bcc imm
		
		// Branch when C == 1 [unsigned greater than or equal], 
		// to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bcs imm
		
		// Branch when ( C == 0 or Z == 1 ) [unsigned less than or equal], 
		// to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bls imm
		
		// Branch when ( C == 1 and Z == 0 ) [unsigned greater than], 
		// to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bhi imm
		
		
		
		// Branch when N == 0, to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bpl imm
		
		// Branch when N == 1, to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bmi imm
		
		// Branch when V == 0, to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bvc imm
		
		// Branch when V == 1, to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bvs imm
		
		
		
		// Branch when N == V [signed greater than or equal], 
		// to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bge imm
		
		// Branch when N != V [signed less than], 
		// to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		blt imm
		
		// Branch when ( N == V and Z == 0 ) [signed greater than], 
		// to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		bgt imm
		
		// Branch when ( N != V or Z == 1 ) [signed less than or equal], 
		// to (pc when instruction starts) + (sign-extended 16-bit immediate value)
		ble imm
		
		
		
		// Pseudo instruction:
		//// rA = rB - (sign-extended imm)
		//// This instruction affects N, V, Z, and C flags.
		//subsi rA, rB, imm


Group 3 Instructions
011o oooo aaaa bbbb  cccc iiii iiii iiii
	
	o:  opcode
	a:  rA
	b:  rB
	c:  rc
	i:  12-bit immediate value
	
	Instructions:
		// Load 32-bit value from address (rB + rC + (sign-extended imm)) into rA.
		ldrxx rA, rB, rC, imm
		
		// Load zero-extended 16-bit value from address (rB + rC + (sign-extended imm)) into rA.
		ldhxx rA, rB, rC, imm
		
		// Load sign-extended 16-bit value from address (rB + rC + (sign-extended imm)) into rA.
		ldshxx rA, rB, rC, imm
		
		// Load zero-extended 8-bit value from address (rB + rC + (sign-extended imm)) into rA.
		ldbxx rA, rB, rC, imm
		
		
		
		// Load sign-extended 8-bit value from address (rB + rC + (sign-extended imm)) into rA.
		ldsbxx rA, rB, rC, imm
		
		// Store 32-bit value in rA to address (rB + rC + (sign-extended imm)).
		strxx rA, rB, rC, imm
		
		// Store low 16 bits of rA to address (rB + rC + (sign-extended imm)).
		sthxx rA, rB, rC, imm
		
		// Store low 8 bits of rA to address (rB + rC + (sign-extended imm)).
		stbxx rA, rB, rC, imm
		
		
		
		// Add two registers,
		// and then add sign extended immediate (can set immediate to zero
		// if needed)
		// rA = (rB + rC) + (sign-extended imm)
		addti rA, rB, rC, imm
		
		// Subtract two registers,
		// and then add sign extended immediate (can set immediate to zero
		// if needed)
		// rA = (rB - rC) + (sign-extended imm)
		subti rA, rB, rC, imm
		
		// Multiply two registers,
		// and then add sign extended immediate (can set immediate to zero
		// if needed)
		// rA = (rB * rC) + (sign-extended imm)
		multi rA, rB, rC, imm
		
		// Fused multiply-add
		// rA = (rA + rB) + rC
		fma rA, rB, rC
		
		
		
		// rA = rB & rC
		// This instruction affects the N and Z flags.
		andt rA, rB, rC
		
		// rA = rB | rC
		// This instruction affects the N and Z flags.
		ort rA, rB, rC
		
		// rA = rB ^ rC
		// This instruction affects the N and Z flags.
		xort rA, rB, rC
		
		// Logical shift left
		// rA = rB << rC
		lslt rA, rB, rC
		
		
		
		// Logical shift right
		lsrt rA, rB, rC
		
		// Arithmetic shift right
		asrt rA, rB, rC
		
		// Rotate rB left by rC bits, then store result in rA.
		rolt rA, rB, rC
		
		// Rotate rB right by rC bits, then store result in rA.
		rort rA, rB, rC
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.


Group 4 Instructions
100o oooo aaaa bbbb  iiii iiii iiii iiii  iiii iiii iiii iiii
	
	o:  opcode
	a:  rA
	b:  rB
	i:  32-bit immediate value
	
	Instructions:
		// Load 32-bit value from address absolute_addr into rA.
		ldra rA, absolute_addr
		
		// Load zero-extended 16-bit value from address absolute_addr into rA.
		// This zero-extends the value.
		ldha rA, absolute_addr
		
		// Load sign-extended 16-bit value from address absolute_addr into rA.
		// This sign-extends the value.
		ldsha rA, absolute_addr
		
		// Load zero-extended 8-bit value from address absolute_addr into rA.
		// This zero-extends the value.
		ldba rA, absolute_addr
		
		
		
		// Load sign-extended 8-bit value from address absolute_addr into rA.
		// This sign-extends the value.
		ldsba rA, absolute_addr
		
		// Store 32-bit value in rA to address absolute_addr.
		stra rA, absolute_addr
		
		// Store low 16 bits of rA to address absolute_addr.
		stha rA, absolute_addr
		
		// Store low 8 bits of rA to address absolute_addr.
		stba rA, absolute_addr
		
		
		
		// Load 32-bit value from address (absolute_addr + rB) into rA.
		ldrax rA, rB, absolute_addr
		
		// Load zero-extended 16-bit value from address (absolute_addr + rB) into rA.
		// This zero-extends the value.
		ldhax rA, rB, absolute_addr
		
		// Load sign-extended 16-bit value from address (absolute_addr + rB) into rA.
		// This sign-extends the value.
		ldshax rA, rB, absolute_addr
		
		// Load zero-extended 8-bit value from address (absolute_addr + rB) into rA.
		// This zero-extends the value.
		ldbax rA, rB, absolute_addr
		
		
		
		// Load sign-extended 8-bit value from address (absolute_addr + rB) into rA.
		// This sign-extends the value.
		ldsbax rA, rB, absolute_addr
		
		// Store 32-bit value in rA to address (absolute_addr + rB).
		strax rA, rB, absolute_addr
		
		// Store low 16 bits of rA to address (absolute_addr + rB).
		sthax rA, rB, absolute_addr
		
		// Store low 8 bits of rA to address (absolute_addr + rB).
		stbax rA, rB, absolute_addr
		
		
		
		// rA = 32-bit immediate
		cpyi rA, imm
		
		// Set pc to destination address in absolute_addr.
		jumpa absolute_addr
		
		// Set pc to destination address in (rA + absolute_addr).
		jumpax rA, absolute_addr
		
		// Set pc to destination address in (rA + rB + absolute_addr).
		jumpxx rA, rB, absolute_addr
		
		
		
		// Subroutine call using absolute_addr as destination address. 
		// The return address is stored in the link register (lr).
		calla absolute_addr
		
		// Subroutine call using (rA + absolute_addr) as destination address. 
		// The return address is stored in the link register (lr).
		callax rA, absolute_addr
		
		// Subroutine call using (rA + rB + absolute_addr) as destination address. 
		// The return address is stored in the link register (lr).
		callxx rA, rB, absolute_addr
		
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
		
		
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		// Reserved for future expansion.
		
